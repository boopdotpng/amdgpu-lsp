[
  {
    "name": "DS_ADD_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_SUB_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_RSUB_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in a location in a data share from a value stored in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_INC_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_DEC_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_AND_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_OR_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_XOR_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MSKOR_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 32-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from one vector input register and then 32 bits of data from a second vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2ST64_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from one vector input register and then 32 bits of data from a second vector input register into a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare an unsigned 32-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare a single-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_NOP",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Do nothing.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_PK_ADD_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_PK_ADD_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_ADDTID_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from a vector input register into a data share. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "DATA0"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_RTN_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_SUB_RTN_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_RSUB_RTN_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in a location in a data share from a value stored in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_INC_RTN_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_DEC_RTN_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_AND_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_OR_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_XOR_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MSKOR_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 32-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Swap two unsigned 32-bit integer values in the data registers with two locations in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2ST64_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Swap two unsigned 32-bit integer values in the data registers with two locations in a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare an unsigned 32-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare a single-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRAP_RTN_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Given a minuend from a location in data share and a subtrahend from a vector register, subtract the two values iff the result is nonnegative; otherwise add a value from a second vector register to the memory location.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_RTN_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from one location in a data share and then 32 bits of data from a second location in a data share and store the results into a 64-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2ST64_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from one location in a data share and then 32 bits of data from a second location in a data share and store the results into a 64-bit vector register. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of signed data from a data share, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from a data share, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_SWIZZLE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Dword swizzle, no data is written to LDS memory.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_PERMUTE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Forward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave. It uses LDS to implement an arbitrary swizzle across threads in a wavefront.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_BPERMUTE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Backward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave. It uses LDS hardware to implement an arbitrary swizzle across threads in a wavefront.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_SUB_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_RSUB_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in a location in a data share from a value stored in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_INC_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_DEC_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_AND_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_OR_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_XOR_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MSKOR_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 64-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from one vector input register and then 64 bits of data from a second vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2ST64_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from one vector input register and then 64 bits of data from a second vector input register into a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare an unsigned 64-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare a double-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B8_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from the high bits of a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B16_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from the high bits of a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U8_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 16 bits and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U8_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 16 bits and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I8_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 16 bits and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I8_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 16 bits and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U16_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from a data share and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U16_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from a data share and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add a double-precision float value in the data register to a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_RTN_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_SUB_RTN_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_RSUB_RTN_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in a location in a data share from a value stored in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_INC_RTN_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_DEC_RTN_U64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_AND_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_OR_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_XOR_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MSKOR_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 64-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Swap two unsigned 64-bit integer values in the data registers with two locations in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2ST64_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Swap two unsigned 64-bit integer values in the data registers with two locations in a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare an unsigned 64-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Compare a double-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Update the data share with the selected value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from one location in a data share and then 64 bits of data from a second location in a data share and store the results into a 128-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2ST64_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from one location in a data share and then 64 bits of data from a second location in a data share and store the results into a 128-bit vector register. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_RTN_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add a double-precision float value in the data register to a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CONDXCHG32_RTN_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Perform 2 conditional write exchanges, where each conditional write exchange writes a 32 bit value from a data register to a location in data share iff the most significant bit of the data value is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_ADDTID_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from a data share into a vector register. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_PK_ADD_RTN_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_PK_ADD_RTN_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CONSUME",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract (count_bits(exec_mask)) from the value stored in DS memory at (M0.base + instr_offset) if GDS, or at instr_offset if LDS. Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_APPEND",
    "architectures": [
      "cdna4"
    ],
    "description": "Add (count_bits(exec_mask)) to the value stored in DS memory at (M0.base + instr_offset) if GDS, or at instr_offset if LDS. Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B96",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 96 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B128",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 128 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B64_TR_B4",
    "architectures": [
      "cdna4"
    ],
    "description": "Read 64 bits of data per lane from data share. Interpret the data as a matrix with 4 bit elements and transpose the matrix. Store the result into vector registers.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B96_TR_B6",
    "architectures": [
      "cdna4"
    ],
    "description": "Read 96 bits of data per lane from data share. Interpret the data as a matrix with 6 bit elements and transpose the matrix. Store the result into vector registers.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B64_TR_B8",
    "architectures": [
      "cdna4"
    ],
    "description": "Read 64 bits of data per lane from data share. Interpret the data as a matrix with 8 bit elements and transpose the matrix. Store the result into vector registers.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B64_TR_B16",
    "architectures": [
      "cdna4"
    ],
    "description": "Read 64 bits of data per lane from data share. Interpret the data as a matrix with 16 bit elements and transpose the matrix. Store the result into vector registers.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B96",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 96 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B128",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 128 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "FLAT_LOAD_UBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_USHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SSHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 96 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 128 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_BYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from a vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_BYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_SHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from a vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 96 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 128 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_UBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_UBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SHORT_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC",
    "architectures": [
      "cdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC",
    "architectures": [
      "cdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a single-precision float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a double-precision float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Update the flat aperture with the selected value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "GLOBAL_LOAD_UBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_USHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SSHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 96 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 128 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_BYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from a vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_BYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_SHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from a vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 96 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 128 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_UBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_UBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SHORT_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_UBYTE",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 8 bits of untyped data from the global aperture, zero extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_SBYTE",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 8 bits of untyped data from the global aperture, sign extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_USHORT",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 16 bits of untyped data from the global aperture, zero extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_SSHORT",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 16 bits of untyped data from the global aperture, sign extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_DWORD",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 32 bits of untyped data from the global aperture and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC",
    "architectures": [
      "cdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC",
    "architectures": [
      "cdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a single-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a double-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Update the global aperture with the selected value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the SC0 bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_DWORDX4",
    "architectures": [
      "cdna4"
    ],
    "description": "Untyped buffer load 4 dwords, store result into data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_DWORDX3",
    "architectures": [
      "cdna4"
    ],
    "description": "Untyped buffer load 3 dwords, store result into data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "SCRATCH_LOAD_UBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_USHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SSHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 96 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 128 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_BYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from a vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_BYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_SHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from a vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 96 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 128 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_UBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_UBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SHORT_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_UBYTE",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 8 bits of untyped data from the scratch aperture, zero extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_SBYTE",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 8 bits of untyped data from the scratch aperture, sign extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_USHORT",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 16 bits of untyped data from the scratch aperture, zero extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_SSHORT",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 16 bits of untyped data from the scratch aperture, sign extend to 32 bits and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_DWORD",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Load 32 bits of untyped data from the scratch aperture and store the result into a data share.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 16 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the low 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 16 bits of data from the low 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XY",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XYZ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XYZW",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_USHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SSHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 32 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 64 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 96 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 128 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_BYTE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_BYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_SHORT",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 32 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 64 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 96 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Store 128 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SHORT_D16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SHORT_D16_HI",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_HI_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the high 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_HI_X",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Convert 16 bits of data from the high 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_WBL2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Write back L2 cache. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_INV",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Invalidate CU and/or L2 cache depending on sc0 and sc1 bits. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC",
    "architectures": [
      "cdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC",
    "architectures": [
      "cdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a single-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a double-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Update the buffer surface with the selected value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the SC0 bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "S_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 32 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 64 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 128 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 256 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 512 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 32 bits of data from the scalar scratch aperture into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 64 bits of data from the scalar scratch aperture into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 128 bits of data from the scalar scratch aperture into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 32 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 64 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 128 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 256 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Load 512 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 32 bits of data from a scalar register into the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 64 bits of data from a scalar register into the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 128 bits of data from a scalar register into the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 32 bits of data from a scalar register into the scalar scratch aperture.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 64 bits of data from a scalar register into the scalar scratch aperture.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 128 bits of data from a scalar register into the scalar scratch aperture.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_STORE_DWORD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 32 bits of data from a scalar register into a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_STORE_DWORDX2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 64 bits of data from a scalar register into a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_STORE_DWORDX4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store 128 bits of data from a scalar register into a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_INV",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Invalidate the scalar data L0 cache.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_WB",
    "architectures": [
      "cdna4"
    ],
    "description": "Write back dirty data in the scalar data L0 cache.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_INV_VOL",
    "architectures": [
      "cdna4"
    ],
    "description": "Invalidate the scalar data L0 cache volatile lines.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_WB_VOL",
    "architectures": [
      "cdna4"
    ],
    "description": "Write back dirty data in the scalar data L0 cache volatile lines.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_MEMTIME",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Return current 64-bit timestamp.",
    "args": [
      "SDATA"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_MEMREALTIME",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Return current 64-bit RTC.",
    "args": [
      "SDATA"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATC_PROBE",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Probe or prefetch an address into the scalar data cache.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "immediate",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATC_PROBE_BUFFER",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Probe or prefetch an address into the scalar data cache.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "immediate",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_DISCARD",
    "architectures": [
      "cdna4"
    ],
    "description": "Discard one dirty scalar data L0 cache line. A cache line is 64 bytes.",
    "args": [
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_DISCARD_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Discard two consecutive dirty scalar data L0 cache lines. A cache line is 64 bytes.",
    "args": [
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SWAP",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a scalar buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_ADD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SUB",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_AND",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_OR",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_XOR",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_INC",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a scalar buffer surface with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_DEC",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a scalar buffer surface with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a scalar buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_ADD_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SUB_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface. Update the scalar buffer with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_AND_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_OR_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_XOR_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_INC_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a scalar buffer surface with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_DEC_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a scalar buffer surface with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SWAP",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the scalar memory. Modify the memory location with a value in the data source register iff the comparison is equal.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_ADD",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SUB",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMIN",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMAX",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_AND",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_OR",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_XOR",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_INC",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the scalar memory with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_DEC",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the scalar memory with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the scalar memory. Modify the memory location with a value in the data source register iff the comparison is equal.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_ADD_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SUB_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory. Update the scalar memory with the selected value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_AND_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_OR_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_XOR_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_INC_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the scalar memory with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_DEC_X2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the scalar memory with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_MOV_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move scalar input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOV_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move scalar input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMOV_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move scalar input into a scalar register iff SCC is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMOV_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move scalar input into a scalar register iff SCC is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOT_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise negation on a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOT_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise negation on a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_WQM_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given an active pixel mask in a scalar input, calculate whole quad mode mask for that input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_WQM_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given an active pixel mask in a scalar input, calculate whole quad mode mask for that input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BREV_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Reverse the order of bits in a scalar input and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BREV_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Reverse the order of bits in a scalar input and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT0_I32_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of \"0\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT0_I32_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of \"0\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT1_I32_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of \"1\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT1_I32_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of \"1\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF0_I32_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of trailing \"1\" bits before the first \"0\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"0\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF0_I32_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of trailing \"1\" bits before the first \"0\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"0\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF1_I32_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF1_I32_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a scalar register. Store -1 if all input bits are the same.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32_I64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a scalar register. Store -1 if all input bits are the same.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_SEXT_I32_I8",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Sign extend a signed 8 bit scalar input to 32 bits and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_SEXT_I32_I16",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Sign extend a signed 16 bit scalar input to 32 bits and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET0_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 0.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET0_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 0.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET1_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 1.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET1_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 1.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_GETPC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store the address of the next instruction to a scalar register.",
    "args": [
      "SDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_SETPC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Jump to an address specified in a scalar register.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_SWAPPC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store the address of the next instruction to a scalar register and then jump to an address specified in the scalar input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_RFE_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Return from the exception handler. Clear the wave's PRIV bit and then jump to an address specified by the scalar input.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_AND_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_QUADMASK_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Reduce a pixel mask from the scalar input into a quad mask, store the result in a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_QUADMASK_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Reduce a pixel mask from the scalar input into a quad mask, store the result in a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOVRELS_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move data from a relatively-indexed scalar register into another scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_MOVRELS_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move data from a relatively-indexed scalar register into another scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_MOVRELD_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move data from a scalar input into a relatively-indexed scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOVRELD_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move data from a scalar input into a relatively-indexed scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CBRANCH_JOIN",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Conditional branch join point (end of conditional branch block).",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ABS_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the absolute value of a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_SET_GPR_IDX_IDX",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the index used in vector GPR indexing.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN1_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN1_SAVEEXEC_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN1_WREXEC_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_WREXEC_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITREPLICATE_B64_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Substitute each bit of a 32 bit scalar input with two instances of itself and store the result into a 64 bit scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_U32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Add two unsigned 32-bit integer inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_U32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_I32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Add two signed 32-bit integer inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_I32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second signed 32-bit integer input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADDC_U32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Add two unsigned 32-bit integer inputs and a carry-in bit from SCC, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUBB_U32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, subtract the carry-in bit, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CSELECT_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the first input if SCC is true otherwise select the second input, then store the selected input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CSELECT_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the first input if SCC is true otherwise select the second input, then store the selected input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise NAND on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise NAND on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise NOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise NOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XNOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XNOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift left of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift left of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHR_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift right of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHR_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift right of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ASHR_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the arithmetic shift right (preserving sign bit) of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ASHR_I64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the arithmetic shift right (preserving sign bit) of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFM_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result in a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFM_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result in a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two signed 32-bit integer inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a signed bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_U64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_I64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a signed bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CBRANCH_G_FORK",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Conditional branch using branch-stack.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ABSDIFF_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the absolute value of difference between two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_RFE_RESTORE_B64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Return from exception handler and continue. This instruction may only be used within a trap handler.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2"
    ]
  },
  {
    "name": "S_MUL_HI_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned integers and store the high 32 bits of the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_HI_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed integers and store the high 32 bits of the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL1_ADD_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 1, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL2_ADD_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 2, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL3_ADD_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 3, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL4_ADD_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 4, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_LL_B32_B16",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_LH_B32_B16",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_HH_B32_B16",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GT_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GE_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LT_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LE_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GT_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GE_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LT_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LE_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP0_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 0.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP1_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 1.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP0_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 0.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP1_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 1.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_SETVSKIP",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Enables or disables VSKIP mode.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_SET_GPR_IDX_ON",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Enable GPR indexing mode.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_U64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_U64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOVK_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Sign extend a literal 16-bit constant and store the result into a scalar register.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMOVK_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move the sign extension of a literal 16-bit constant into a scalar register iff SCC is nonzero.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_EQ_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is equal to the sign extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_LG_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is less than or greater than the sign extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_GT_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is greater than the sign extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_GE_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is greater than or equal to the sign extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_LT_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is less than the sign extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_LE_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is less than or equal to the sign extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_EQ_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is equal to the zero extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_LG_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is less than or greater than the zero extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_GT_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is greater than the zero extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_GE_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is greater than or equal to the zero extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_LT_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is less than the zero extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CMPK_LE_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set SCC to 1 iff scalar input is less than or equal to the zero extension of a literal 16-bit constant.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_ADDK_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add a scalar input and the sign extension of a literal 16-bit constant, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_MULK_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply a scalar input with the sign extension of a literal 16-bit constant and store the result into a scalar register.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_CBRANCH_I_FORK",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Conditional branch using branch-stack.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "label"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_GETREG_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Read some or all of a hardware register into the LSBs of destination.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_SETREG_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Write some or all of the LSBs of source argument into a hardware register.",
    "args": [
      "SIMM16",
      "SDST"
    ],
    "arg_types": [
      "special",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_SETREG_IMM32_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Write some or all of the LSBs of a 32-bit literal constant into a hardware register; this instruction requires a 32-bit literal constant.",
    "args": [
      "SIMM16",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "special",
      "immediate"
    ],
    "available_encodings": [
      "SOPK_INST_LITERAL"
    ]
  },
  {
    "name": "S_CALL_B64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Store the address of the next instruction to a scalar register and then jump to a constant offset relative to the current PC.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "label"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_NOP",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Do nothing. Delay issue of next instruction by a small, fixed amount.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_ENDPGM",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "End of program; terminate wavefront.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_BRANCH",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAKEUP",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Allow a wave to 'ping' all the other waves in its threadgroup to force them to wake up early from an S_SLEEP instruction.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_SCC0",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If SCC is 0 then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_SCC1",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If SCC is 1 then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_VCCZ",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If VCCZ is 1 then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_VCCNZ",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If VCCZ is 0 then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_EXECZ",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If EXECZ is 1 then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_EXECNZ",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If EXECZ is 0 then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_BARRIER",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Synchronize waves within a threadgroup.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SETKILL",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Kill this wave if the least significant bit of the immediate constant is 1.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAITCNT",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Wait for the counts of outstanding local data share, vector memory and export instructions to be at or below the specified levels.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SETHALT",
    "architectures": [
      "cdna4",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set or clear the HALT status bit.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SLEEP",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Cause a wave to sleep for up to ~8000 clocks.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SETPRIO",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Change wave user priority.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SENDMSG",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Send a message upstream to graphics control hardware.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SENDMSGHALT",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Send a message to upstream control hardware and then HALT the wavefront; see S_SENDMSG for details.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_TRAP",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Enter the trap handler.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_ICACHE_INV",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Invalidate entire first level instruction cache.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_INCPERFLEVEL",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Increment performance counter specified in SIMM16[3:0] by 1.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_DECPERFLEVEL",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Decrement performance counter specified in SIMM16[3:0] by 1.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_TTRACEDATA",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Send M0 as user data to the thread trace stream.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_CDBGSYS",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If the system debug flag is set then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_CDBGUSER",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If the user debug flag is set then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_CDBGSYS_OR_USER",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If either the system debug flag or the user debug flag is set then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CBRANCH_CDBGSYS_AND_USER",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "If both the system debug flag and the user debug flag are set then jump to a constant offset relative to the current PC.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "label"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_ENDPGM_SAVED",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "End of program; signal that a wave has been saved by the context-switch trap handler and terminate wavefront.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SET_GPR_IDX_OFF",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Clear GPR indexing mode.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SET_GPR_IDX_MODE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Modify the mode used for vector GPR indexing.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_ENDPGM_ORDERED_PS_DONE",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "End of program; signal that a wave has exited its POPS critical section and terminate wavefront.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SET_VALU_COEXEC_MODE",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Set the vector ALU co-execution mode to the value encoded in SIMM16[1:0] for the next VALU instruction. The co-execution mode is cleared to zero after the next VALU instruction is issued.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "V_NOP",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Do nothing.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_MOV_B32",
    "architectures": [
      "cdna4"
    ],
    "description": "Move 32-bit data from a vector input into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_READFIRSTLANE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Read the scalar value in the lowest active lane of the input vector register and store it into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_I32_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a double-precision float input to a signed 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_CVT_F64_I32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a signed 32-bit integer input to a double-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_CVT_F32_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a signed 32-bit integer input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from an unsigned 32-bit integer input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_U32_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a single-precision float input to an unsigned 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_I32_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F16_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a single-precision float input to a half-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a half-precision float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_RPI_I32_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value using round to nearest integer semantics (ignore the default rounding mode) and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_FLR_I32_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value using round-down semantics (ignore the default rounding mode) and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_OFF_F32_I4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a signed 4-bit integer input to a single-precision float value using an offset table and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a double-precision float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_CVT_F64_F32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a single-precision float input to a double-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE0",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert an unsigned byte in byte 0 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE1",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert an unsigned byte in byte 1 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE2",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert an unsigned byte in byte 2 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE3",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert an unsigned byte in byte 3 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_U32_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a double-precision float input to an unsigned 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_CVT_F64_U32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from an unsigned 32-bit integer input to a double-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_TRUNC_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the integer part of a double-precision float input using round toward zero semantics and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_CEIL_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the double-precision float input up to next integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_RNDNE_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the double-precision float input to the nearest even integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_FLOOR_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the double-precision float input down to previous integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_FRACT_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the fractional portion of a single-precision float input and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_TRUNC_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the integer part of a single-precision float input using round toward zero semantics and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CEIL_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the single-precision float input up to next integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RNDNE_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the single-precision float input to the nearest even integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FLOOR_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the single-precision float input down to previous integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_EXP_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate 2 raised to the power of the single-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_LOG_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the base 2 logarithm of the single-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RCP_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the single-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RCP_IFLAG_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the vector float input in a manner suitable for integer division and store the result into a vector register. This opcode is intended for use as part of an integer division macro.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RSQ_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the square root of the single-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RCP_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the double-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_RSQ_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the square root of the double-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_SQRT_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the square root of the single-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_SQRT_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the square root of the double-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_SIN_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the trigonometric sine of a single-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_COS_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the trigonometric cosine of a single-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_NOT_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise negation on a vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_BFREV_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Reverse the order of bits in a vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FFBH_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a vector input and store the result into a vector register. Store -1 if there are no \"1\" bits.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FFBL_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a vector input and store the result into a vector register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FFBH_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a vector input and store the result into a vector register. Store -1 if all input bits are the same.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FREXP_EXP_I32_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract the exponent of a double-precision float input and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_FREXP_MANT_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract the binary significand, or mantissa, of a double-precision float input and store the result as a double-precision float into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_FRACT_F64",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the fractional portion of a double-precision float input and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP"
    ]
  },
  {
    "name": "V_FREXP_EXP_I32_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract the exponent of a single-precision float input and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FREXP_MANT_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract the binary significand, or mantissa, of a single-precision float input and store the result as a single-precision float into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CLREXCP",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Clear this wave's exception state in the vector ALU.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_SCREEN_PARTITION_4SE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "4SE version of LUT instruction for screen partitioning/filtering. This opcode is intended to help accelerate screen partitioning in the 4SE case only. 2SE and 1SE cases use normal ALU instructions.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_MOV_B64",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Move data from a 64-bit vector input into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F16_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from an unsigned 16-bit integer input to a half-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F16_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a signed 16-bit integer input to a half-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_U16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a half-precision float input to an unsigned 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_I16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a half-precision float input to a signed 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RCP_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the half-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_SQRT_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the square root of the half-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RSQ_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the reciprocal of the square root of the half-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_LOG_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the base 2 logarithm of the half-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_EXP_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate 2 raised to the power of the half-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FREXP_MANT_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract the binary significand, or mantissa, of a half-precision float input and store the result as a half-precision float into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FREXP_EXP_I16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract the exponent of a half-precision float input and store the result as a signed 16-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FLOOR_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the half-precision float input down to previous integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CEIL_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the half-precision float input up to next integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_TRUNC_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the integer part of a half-precision float input using round toward zero semantics and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_RNDNE_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Round the half-precision float input to the nearest even integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_FRACT_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the fractional portion of a half-precision float input and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_SIN_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the trigonometric sine of a half-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_COS_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the trigonometric cosine of a half-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_EXP_LEGACY_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Power with legacy semantics.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_LOG_LEGACY_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Base 2 logarithm with legacy semantics.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_NORM_I16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a half-precision float input to a signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_NORM_U16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from a half-precision float input to an unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_SAT_PK_U8_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Given 2 signed 16-bit integer inputs, saturate each input over an unsigned 8-bit integer range, pack the resulting values into a packed 16-bit value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_SWAP_B32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Swap the values in two vector registers.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ACCVGPR_MOV_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Move data from one accumulator register to another accumulator register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Convert from an FP8 float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_F32_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Convert from a BF8 float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_PK_F32_FP8",
    "architectures": [
      "cdna4",
      "rdna4",
      "cdna3"
    ],
    "description": "Convert from a packed 2-component FP8 float input to a packed single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CVT_PK_F32_BF8",
    "architectures": [
      "cdna4",
      "rdna4",
      "cdna3"
    ],
    "description": "Convert from a packed 2-component BF8 float input to a packed single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_PRNG_B32",
    "architectures": [
      "cdna4"
    ],
    "description": "Generate a pseudorandom number using an LFSR (linear feedback shift register) seeded with the vector input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_PERMLANE16_SWAP_B32",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap data between two vector registers. Odd rows of the first operand are swapped with even rows of the second operand (one row is 16 lanes).",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_PERMLANE32_SWAP_B32",
    "architectures": [
      "cdna4"
    ],
    "description": "Swap data between two vector registers. Rows 2 and 3 of the first operand are swapped with rows 0 and 1 of the second operand (one row is 16 lanes).",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_F32_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a BF16 float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CNDMASK_B32",
    "architectures": [
      "cdna4",
      "rdna3.5"
    ],
    "description": "Copy data from one of two inputs based on the per-lane condition code and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_ADD_F32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUB_F32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second floating point input from the first input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUBREV_F32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the first floating point input from the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_FMAC_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_MUL_F32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MUL_I32_I24",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed 24-bit integer inputs and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MUL_HI_I32_I24",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed 24-bit integer inputs and store the high 32 bits of the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MUL_U32_U24",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MUL_HI_U32_U24",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs and store the high 32 bits of the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MIN_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAX_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MIN_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAX_I32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MIN_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAX_U32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_LSHRREV_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_ASHRREV_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_LSHLREV_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_AND_B32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_OR_B32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise OR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_XOR_B32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_DOT2C_F32_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Compute the dot product of two packed 2-D BF16 float inputs in the single-precision float domain and accumulate with the single-precision float value in the destination register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_FMAMK_F32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply a single-precision float input with a literal constant and add a second single-precision float input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "OPR_SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMAAK_F32",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a literal constant using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_CO_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 32-bit integer inputs, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUB_CO_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUBREV_CO_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_ADDC_CO_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Add two unsigned 32-bit integer inputs and a bit from a carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUBB_CO_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUBBREV_CO_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_ADD_F16",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUB_F16",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second floating point input from the first input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUBREV_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the first floating point input from the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MUL_F16",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAC_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register. Implements IEEE rules and non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_MADMK_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply a floating point input with a literal constant and add a second floating point input, and store the result into a vector register. Implements IEEE rules.",
    "args": [
      "VDST",
      "SRC0",
      "OPR_SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_MADAK_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply two floating point inputs and add a literal constant, and store the result into a vector register. Implements IEEE rules.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned 16-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUB_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the second unsigned 16-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUBREV_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the first unsigned 16-bit integer input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MUL_LO_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs and store the low bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_LSHLREV_B16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_LSHRREV_B16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_ASHRREV_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAX_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MIN_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAX_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAX_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MIN_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MIN_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_LDEXP_F16",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_ADD_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUB_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUBREV_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_DOT2C_F32_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain and accumulate with the single-precision float value in the destination register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_DOT2C_I32_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 2-D signed 16-bit integer inputs in the signed 32-bit integer domain and accumulate with the signed 32-bit integer value in the destination register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_DOT4C_I32_I8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 4-D signed 8-bit integer inputs in the signed 32-bit integer domain and accumulate with the signed 32-bit integer value in the destination register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_DOT8C_I32_I4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 8-D signed 4-bit integer inputs in the signed 32-bit integer domain and accumulate with the signed 32-bit integer value in the destination register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_FMAC_F32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_PK_FMAC_F16",
    "architectures": [
      "cdna4",
      "rdna4",
      "rdna3.5",
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_XNOR_B32",
    "architectures": [
      "cdna4",
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XNOR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_MAD_I32_I24",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed 24-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from a third input, and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_U32_U24",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs in the unsigned 32-bit integer domain, add a unsigned 32-bit integer value from a third input, and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CUBEID_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the cubemap face ID of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CUBESC_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the cubemap S coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CUBETC_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the cubemap T coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CUBEMA_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Compute the cubemap major axis of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BFE_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset from the second input and size from the third input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BFE_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Extract a signed bitfield from the first input using field offset from the second input and size from the third input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BFI_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Overwrite a bitfield in the third input with a bitfield from the second input using a mask from the first input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_FMA_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_FMA_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two double-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LERP_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Average two 4-D vectors stored as packed bytes in the first two inputs with rounding control provided by the third input, then store the result into a vector register. Each byte in the third input acts as a rounding mode for the corresponding element; if the LSB is set then 0.5 rounds up, otherwise 0.5 truncates.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ALIGNBIT_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Align a 64-bit value encoded in the first two inputs to a bit position specified in the third input, then store the result into a 32-bit vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ALIGNBYTE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Align a 64-bit value encoded in the first two inputs to a byte position specified in the third input, then store the result into a 32-bit vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN3_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN3_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN3_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX3_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX3_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX3_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the median of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the median of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the median of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SAD_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SAD_HI_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, shift the sum left by 16 bits, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SAD_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 2-component unsigned 16-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SAD_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the absolute difference of two unsigned 32-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_U8_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert a single-precision float value from the first input to an unsigned 8-bit integer value and pack the result into one byte of the third input using the second input as a byte select. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a single-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a double-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_DIV_SCALE_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a single-precision float value to scale in the first input, a denominator in the second input and a numerator in the third input, scale the first input for division if required to avoid subnormal terms appearing during application of the Newton-Raphson correction method. Store the scaled result into a vector register and set the vector condition code iff post-scaling is required.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_DIV_SCALE_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a double-precision float value to scale in the first input, a denominator in the second input and a numerator in the third input, scale the first input for division if required to avoid subnormal terms appearing during application of the Newton-Raphson correction method. Store the scaled result into a vector register and set the vector condition code iff post-scaling is required.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_DIV_FMAS_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a third input using fused multiply add, then scale the exponent of the result by a fixed factor if the vector condition code is set. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_DIV_FMAS_F64",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two double-precision float inputs and add a third input using fused multiply add, then scale the exponent of the result by a fixed factor if the vector condition code is set. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MSAD_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, except that elements where the second input (known as the reference input) is zero are not included in the sum. Add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_QSAD_PK_U16_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Perform the V_SAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Truncate each result to 16 bits, pack the values into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 16-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MQSAD_PK_U16_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Perform the V_MSAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Truncate each result to 16 bits, pack the values into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 16-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MQSAD_U32_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Perform the V_MSAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Pack each 32-bit value into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 32-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_U64_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned integer inputs, add a third unsigned integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_MAD_I64_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed integer inputs, add a third signed integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_MAD_LEGACY_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply add of FP16 values. Implements IEEE rules and non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_LEGACY_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply add of unsigned short values. Has non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_LEGACY_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply add of signed short values. Has non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_PERM_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Permute a 64-bit value constructed from two vector inputs (most significant bits come from the first input) using a per-lane selector from the third input. The lane selector allows each byte of the result to choose from any of the 8 input bytes, perform sign extension or pad with 0/1 bits. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_FMA_LEGACY_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Fused half precision multiply add. Implements IEEE rules and non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_DIV_FIXUP_LEGACY_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Half precision division fixup. Has non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PKACCUM_U8_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert a single-precision float value in the first input to an unsigned 8-bit integer value and store the result into one byte of the destination register using the second input as a byte select.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_U32_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from a third input, and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_I32_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed 16-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from a third input, and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_XAD_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR of the first two vector inputs, then add the third vector input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN3_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN3_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN3_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX3_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX3_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX3_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the median of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the median of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the median of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LSHL_ADD_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then add the third input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ADD_LSHL_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add the first two integer inputs, then given a shift count in the third input, calculate the logical shift left of the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ADD3_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add three unsigned inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LSHL_OR_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then calculate the bitwise OR of the intermediate result and the third input, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_AND_OR_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate bitwise AND on the first two vector inputs, then compute the bitwise OR of the intermediate result and the third vector input, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_OR3_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate the bitwise OR of three vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two half-precision float inputs and add a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs, add an unsigned 16-bit integer value from a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed 16-bit integer inputs, add a signed 16-bit integer value from a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_FMA_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two half-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a half-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LSHL_ADD_U64",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then add the third input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BITOP3_B16",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate the generic bitwise operation of three 16-bit vector inputs using a truth table encoded in the instruction and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BITOP3_B32",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate the generic bitwise operation of three 32-bit vector inputs using a truth table encoded in the instruction and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_FP8_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale two single-precision float inputs using the exponent provided by the third single-precision float input, then convert the values to a packed FP8 float value with round toward nearest even semantics. Store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_BF8_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale two single-precision float inputs using the exponent provided by the third single-precision float input, then convert the values to a packed BF8 float value with round toward nearest even semantics. Store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_FP8_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a single-precision float input using the exponent provided by the third single-precision float input, then convert the values to an FP8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_BF8_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a single-precision float input using the exponent provided by the third single-precision float input, then convert the values to a BF8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_F32_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component FP8 float input to a packed single-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_F32_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component BF8 float input to a packed single-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_F32_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from an FP8 float input to a single-precision float value, then scale the value using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_F32_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a BF8 float input to a single-precision float value, then scale the value using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_FP4_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale two single-precision float inputs using the exponent provided by the third single-precision float input, then convert the values to a packed FP4 float value with round toward nearest even semantics. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK_FP4_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component single-precision float input using the exponent provided by the third single-precision float input, then convert the values to a packed FP4 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_F32_FP4",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component FP4 float input to a packed single-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_FP8_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component half-precision float input using the exponent provided by the second single-precision float input, then convert the values to a packed FP8 float value with round toward nearest even semantics. Store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_BF8_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component half-precision float input using the exponent provided by the second single-precision float input, then convert the values to a packed BF8 float value with round toward nearest even semantics. Store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_FP8_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a half-precision float input using the exponent provided by the third single-precision float input, then convert the values to an FP8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_BF8_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a half-precision float input using the exponent provided by the third single-precision float input, then convert the values to a BF8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_FP8_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component BF16 float input using the exponent provided by the second single-precision float input, then convert the values to a packed FP8 float value with round toward nearest even semantics. Store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_BF8_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component BF16 float input using the exponent provided by the second single-precision float input, then convert the values to a packed BF8 float value with round toward nearest even semantics. Store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_FP8_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a BF16 float input using the exponent provided by the third single-precision float input, then convert the values to an FP8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_BF8_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a BF16 float input using the exponent provided by the third single-precision float input, then convert the values to a BF8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_F16_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component FP8 float input to a packed half-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_F16_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component BF8 float input to a packed half-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_F16_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from an FP8 float input to a half-precision float value, then scale the value using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_F16_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a BF8 float input to a half-precision float value, then scale the value using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_FP4_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component half-precision float input using the exponent provided by the second single-precision float input, then convert the values to a packed FP4 float value with round toward nearest even semantics. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_FP4_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component BF16 float input using the exponent provided by the second single-precision float input, then convert the values to a packed FP4 float value with round toward nearest even semantics. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK_FP4_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component half-precision float input using the exponent provided by the third single-precision float input, then convert the values to a packed FP4 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK_FP4_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 2-component BF16 float input using the exponent provided by the third single-precision float input, then convert the values to a packed FP4 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL[3:2] to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_F16_FP4",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component FP4 float input to a packed half-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_BF16_FP4",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component FP4 float input to a packed BF16 float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register. The value to convert is loaded from 8 bits of the input using OPSEL[1:0] to determine which byte to read.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_2XPK16_FP6_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale packed 16-component single-precision float vectors from two source inputs using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component FP6 float value. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_2XPK16_BF6_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale packed 16-component single-precision float vectors from two source inputs using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component BF6 float value. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK32_FP6_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component single-precision float input using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component FP6 float value with stochastic rounding using seed data from the second input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK32_BF6_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component single-precision float input using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component BF6 float value with stochastic rounding using seed data from the second input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_F32_FP6",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 32-component FP6 float input to a packed single-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_F32_BF6",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 32-component BF6 float input to a packed single-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_FP6_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component half-precision float input using the exponent provided by the second single-precision float input, then convert the values to a packed 32-component FP6 float value. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_FP6_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component BF16 float input using the exponent provided by the second single-precision float input, then convert the values to a packed 32-component FP6 float value. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_BF6_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component half-precision float input using the exponent provided by the second single-precision float input, then convert the values to a packed 32-component BF6 float value. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_BF6_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component BF16 float input using the exponent provided by the second single-precision float input, then convert the values to a packed 32-component BF6 float value. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK32_FP6_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component half-precision float input using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component FP6 float value with stochastic rounding using seed data from the second input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK32_FP6_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component BF16 float input using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component FP6 float value with stochastic rounding using seed data from the second input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK32_BF6_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component half-precision float input using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component BF6 float value with stochastic rounding using seed data from the second input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_SR_PK32_BF6_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Scale a packed 32-component BF16 float input using the exponent provided by the third single-precision float input, then convert the values to a packed 32-component BF6 float value with stochastic rounding using seed data from the second input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_F16_FP6",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 32-component FP6 float input to a packed half-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_BF16_FP6",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 32-component FP6 float input to a packed BF16 float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_F16_BF6",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 32-component BF6 float input to a packed half-precision float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK32_BF16_BF6",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 32-component BF6 float input to a packed BF16 float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ASHR_PK_I8_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Given two signed 32-bit integers and a shift count, calculate the arithmetic shift right (preserving sign bit) of the two integers, saturate the two results in the signed 8-bit interval [-128, 127], pack the bytes and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ASHR_PK_U8_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Given two signed 32-bit integers and a shift count, calculate the arithmetic shift right (preserving sign bit) of the two integers, saturate the two results in the unsigned 8-bit interval [0, 255], pack the bytes and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_F16_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from two single-precision float inputs to a packed half-precision value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_BF16_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from two single-precision float inputs to a packed BF16 value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_BF16_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component FP8 float input to a packed BF16 float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SCALEF32_PK_BF16_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a packed 2-component BF8 float input to a packed BF16 float value, then scale the packed values using the exponent provided by the second single-precision float input. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ADD_F64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MUL_F64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MIN_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the minimum of two double-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAX_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the maximum of two double-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LDEXP_F64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MUL_LO_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 32-bit integer inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MUL_HI_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two unsigned 32-bit integer inputs and store the high 32 bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MUL_HI_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed 32-bit integer inputs and store the high 32 bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LDEXP_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_READLANE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Read the scalar value in the specified lane of the first input where the lane select is in the second input. Store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_WRITELANE_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Write the scalar value in the first input into the specified lane of a vector register where the lane select is in the second input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BCNT_U32_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Count the number of \"1\" bits in the vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MBCNT_LO_U32_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "For each lane 0 <= N < 32, examine the N least significant bits of the first input and count how many of those bits are \"1\". For each lane 32 <= N < 64, all \"1\" bits in the first input are counted. Add this count to the value in the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MBCNT_HI_U32_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "For each lane 32 <= N < 64, examine the N least significant bits of the first input and count how many of those bits are \"1\". For lane positions 0 <= N < 32 no bits are examined and the count is zero. Add this count to the value in the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LSHLREV_B64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_LSHRREV_B64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ASHRREV_I64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_TRIG_PREOP_F64",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Look up a 53-bit segment of 2/PI using an integer segment select in the second input. Scale the intermediate result by the exponent from the first double-precision float input and store the double-precision float result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_BFM_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PKNORM_I16_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from two single-precision float inputs to a packed signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PKNORM_U16_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from two single-precision float inputs to a packed unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PKRTZ_F16_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert two single-precision float inputs to a packed half-precision float value using round toward zero semantics (ignore the current rounding mode), and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_U16_U32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from two unsigned 32-bit integer inputs to a packed unsigned 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_I16_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from two signed 32-bit integer inputs to a packed signed 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PKNORM_I16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from two half-precision float inputs to a packed signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PKNORM_U16_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Convert from two half-precision float inputs to a packed unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ADD_I32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two signed 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SUB_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the second signed 32-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_ADD_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two signed 16-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SUB_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Subtract the second signed 16-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_PACK_B32_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Pack two half-precision float values into a single 32-bit value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MUL_LEGACY_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_FP8_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Convert from two single-precision float inputs to a packed FP8 float value with round to nearest even semantics and store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_PK_BF8_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Convert from two single-precision float inputs to a packed BF8 float value with round to nearest even semantics and store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SR_FP8_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Convert from a single-precision float input to an FP8 value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SR_BF8_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Convert from a single-precision float input to a BF8 value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SR_F16_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a single-precision float input to a half-precision value with stochastic rounding using seed data from the second input. Store the result into 16 bits of a vector register using OPSEL to determine which word of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_SR_BF16_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Convert from a single-precision float input to a BF16 value with stochastic rounding using seed data from the second input. Store the result into 16 bits of a vector register using OPSEL to determine which word of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MINIMUM3_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the IEEE minimum() of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAXIMUM3_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the IEEE maximum() of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_PK_MAD_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two packed signed 16-bit integer inputs component-wise, add a packed signed 16-bit integer value from a third input component-wise, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MUL_LO_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two packed unsigned 16-bit integer inputs component-wise and store the low bits of each resulting component into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_ADD_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two packed signed 16-bit integer inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_SUB_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second packed signed 16-bit integer input from the first input component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_LSHLREV_B16",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a packed shift count in the first vector input, calculate the component-wise logical shift left of the second packed vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_LSHRREV_B16",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a packed shift count in the first vector input, calculate the component-wise logical shift right of the second packed vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_ASHRREV_I16",
    "architectures": [
      "cdna4",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given a packed shift count in the first vector input, calculate the component-wise arithmetic shift right (preserving sign bit) of the second packed vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MAX_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the component-wise maximum of two packed signed 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MIN_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the component-wise minimum of two packed signed 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MAD_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two packed unsigned 16-bit integer inputs component-wise, add a packed unsigned 16-bit integer value from a third input component-wise, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_ADD_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two packed unsigned 16-bit integer inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_SUB_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second packed unsigned 16-bit integer input from the first input component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MAX_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the component-wise maximum of two packed unsigned 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MIN_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the component-wise minimum of two packed unsigned 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_FMA_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and add a third input component-wise using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_ADD_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two packed half-precision float inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MUL_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MIN_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the component-wise minimum of two packed half-precision float inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MAX_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the component-wise maximum of two packed half-precision float inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT2_F32_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Calculate the dot product of BF16 float 2-vectors from the first and second inputs, convert the product to single-precision float format, add the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MINIMUM3_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the component-wise IEEE minimum() of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MAXIMUM3_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Select the component-wise IEEE maximum() of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MAD_MIX_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply two inputs and add a third input where the inputs are a mix of half-precision float and single-precision float values. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MAD_MIXLO_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply two inputs and add a third input where the inputs are a mix of half-precision float and single-precision float values. Convert the result to a half-precision float. Store the result into the low bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MAD_MIXHI_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply two inputs and add a third input where the inputs are a mix of half-precision float and single-precision float values. Convert the result to a half-precision float. Store the result into the high bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT2_F32_F16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT2_I32_I16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 2-D signed 16-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT2_U32_U16",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 2-D unsigned 16-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT4_I32_I8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 4-D signed 8-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT4_U32_U8",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 4-D unsigned 8-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT8_I32_I4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 8-D signed 4-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_DOT8_U32_U4",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the dot product of two packed 8-D unsigned 4-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X128_F8F6F4",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 matrix in the first input by the 128x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X64_F8F6F4",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 matrix in the first input by the 64x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_PK_FMA_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Multiply two packed single-precision float inputs component-wise and add a third input component-wise using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MUL_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Multiply two packed single-precision float inputs component-wise and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_ADD_F32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Add two packed single-precision float inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MOV_B32",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2"
    ],
    "description": "Move data from two vector inputs into two vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X32_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_16X16X64_I8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x64 matrix in the first input by the 64x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X16_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_32X32X32_I8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x32 matrix in the first input by the 32x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X64_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_I32_16X16X128_I8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 sparse matrix in the first input by the 128x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X128_BF8_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 sparse matrix in the first input by the 128x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X128_BF8_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 sparse matrix in the first input by the 128x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X128_FP8_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 sparse matrix in the first input by the 128x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X1_2B_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x1 matrix in the first input by the 1x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X1_4B_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x1 matrix in the first input by the 1x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X1_16B_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 4x1 matrix in the first input by the 1x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X128_FP8_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 sparse matrix in the first input by the 128x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X2_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x2 matrix in the first input by the 2x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X4_F32",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X32_BF16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_I32_32X32X64_I8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 sparse matrix in the first input by the 64x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X4_2B_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X4_4B_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X4_16B_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X64_BF8_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 sparse matrix in the first input by the 64x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X8_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x8 matrix in the first input by the 8x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X16_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X64_BF8_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 sparse matrix in the first input by the 64x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X64_FP8_BF8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 sparse matrix in the first input by the 64x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_32X32X4_2B_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_16X16X4_4B_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_4X4X4_16B_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X64_FP8_FP8",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 sparse matrix in the first input by the 64x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X32_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X16_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_32X32X16_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_16X16X32_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_ACCVGPR_READ",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move 32 bits of data from an accumulator vector register into an architectural vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_ACCVGPR_WRITE",
    "architectures": [
      "cdna4",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move 32 bits of data from an architectural vector register into an accumulator vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X64_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X32_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X4_2B_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X4_4B_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X4_16B_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X8_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x8 matrix in the first input by the 8x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X16_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X32_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 sparse matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X16_F16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 sparse matrix in the first input by the 16x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X32_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 sparse matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X16_BF16",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 sparse matrix in the first input by the 16x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_I32_16X16X64_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_I32_32X32X32_I8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F64_16X16X4_F64",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F64_4X4X4_4B_F64",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X32_BF8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X32_BF8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X32_FP8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X32_FP8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X16_BF8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X16_BF8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X16_FP8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X16_FP8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x16 matrix in the first input by the 16x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X64_BF8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X64_BF8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X64_FP8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_16X16X64_FP8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 16x64 sparse matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X32_BF8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X32_BF8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X32_FP8_BF8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_SMFMAC_F32_32X32X32_FP8_FP8",
    "architectures": [
      "cdna4",
      "cdna3"
    ],
    "description": "Multiply the 32x32 sparse matrix in the first input by the 32x32 matrix in the second input and accumulate the result into the 32x32 matrix stored in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_SCALE_F32_16X16X128_F8F6F4",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 16x128 matrix in the first input by the 128x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2",
      "SCALE_SRC0",
      "SCALE_SRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3PX2"
    ]
  },
  {
    "name": "V_MFMA_SCALE_F32_32X32X64_F8F6F4",
    "architectures": [
      "cdna4"
    ],
    "description": "Multiply the 32x64 matrix in the first input by the 64x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2",
      "SCALE_SRC0",
      "SCALE_SRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3PX2"
    ]
  },
  {
    "name": "V_CMP_CLASS_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_CLASS_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_CLASS_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LG_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_O_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_U_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLG_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NEQ_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_TRU_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LG_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_O_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_U_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLG_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLE_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLT_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_TRU_F16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LG_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_O_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_U_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLG_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NEQ_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_TRU_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LG_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_O_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_U_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLG_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLE_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLT_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_TRU_F32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LG_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_O_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_U_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLG_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NEQ_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_TRU_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LG_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_O_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_U_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLG_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLE_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLT_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_TRU_F64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_I16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_U16",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_I32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_U32",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_I64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_U64",
    "architectures": [
      "cdna4"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_LOAD_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_B128",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_B256",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 256 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_B512",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 512 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 96 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the scalar memory, sign extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the scalar memory, zero extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of signed data from the scalar memory, sign extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the scalar memory, zero extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_B128",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_B256",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 256 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_B512",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 512 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 96 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from a scalar buffer surface, sign extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from a scalar buffer surface, zero extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of signed data from a scalar buffer surface, sign extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from a scalar buffer surface, zero extend to 32 bits and store the result into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_PREFETCH_INST",
    "architectures": [
      "rdna4"
    ],
    "description": "Prefetch instructions into the shader instruction cache, relative to a base address provided.",
    "args": [
      "SBASE",
      "IOFFSET",
      "SOFFSET",
      "SDATA"
    ],
    "arg_types": [
      "register",
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_PREFETCH_INST_PC_REL",
    "architectures": [
      "rdna4"
    ],
    "description": "Prefetch instructions into the shader instruction cache, relative to the current PC address.",
    "args": [
      "IOFFSET",
      "SOFFSET",
      "SDATA"
    ],
    "arg_types": [
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_PREFETCH_DATA",
    "architectures": [
      "rdna4"
    ],
    "description": "Prefetch data into the scalar data cache, relative to a base address provided.",
    "args": [
      "SBASE",
      "IOFFSET",
      "SOFFSET",
      "SDATA"
    ],
    "arg_types": [
      "register",
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_PREFETCH_DATA",
    "architectures": [
      "rdna4"
    ],
    "description": "Prefetch data into the scalar data cache, relative to a base address provided in a resource descriptor constant.",
    "args": [
      "SBASE",
      "IOFFSET",
      "SOFFSET",
      "SDATA"
    ],
    "arg_types": [
      "register",
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_PREFETCH_DATA_PC_REL",
    "architectures": [
      "rdna4"
    ],
    "description": "Prefetch data into the scalar data cache, relative to the current PC address.",
    "args": [
      "IOFFSET",
      "SOFFSET",
      "SDATA"
    ],
    "arg_types": [
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_CTZ_I32_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CTZ_I32_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CLZ_I32_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CLZ_I32_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CLS_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a scalar register. Store -1 if all input bits are the same.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CLS_I32_I64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a scalar register. Store -1 if all input bits are the same.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT0_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT0_SAVEEXEC_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_NOT0_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_NOT0_SAVEEXEC_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT1_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT1_SAVEEXEC_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_NOT1_SAVEEXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_NOT1_SAVEEXEC_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT0_WREXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT0_WREXEC_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT1_WREXEC_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT1_WREXEC_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOVRELSD_2_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a relatively-indexed scalar register into another relatively-indexed scalar register, using different offsets for each index.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_SENDMSG_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Send a message to upstream control hardware.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_SENDMSG_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Send a message to upstream control hardware.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_SOP1"
    ]
  },
  {
    "name": "S_BARRIER_SIGNAL",
    "architectures": [
      "rdna4"
    ],
    "description": "Signal that a wave has arrived at a barrier. The argument specifies which barrier to signal.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BARRIER_SIGNAL_ISFIRST",
    "architectures": [
      "rdna4"
    ],
    "description": "Signal that a wave has arrived at a barrier and set SCC to indicate if this is the first wave to signal the barrier. The argument specifies which barrier to signal.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ALLOC_VGPR",
    "architectures": [
      "rdna4"
    ],
    "description": "Attempt to set the wave's VGPR allocation to the specified number of VGPRs. The new VGPR count may be specified as a constant or in an SGPR. The request is rounded up to the next block size so a successful allocation may include more than the requested number of VGPRs.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_SLEEP_VAR",
    "architectures": [
      "rdna4"
    ],
    "description": "Cause a wave to sleep for up to ~8000 clocks, or to sleep until an external event wakes the wave up.",
    "args": [
      "SSRC0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CEIL_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Round the single-precision float input up to next integer and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLOOR_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Round the single-precision float input down to previous integer and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_TRUNC_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Compute the integer part of a single-precision float input using round toward zero semantics and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_RNDNE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Round the single-precision float input to the nearest even integer and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_F32_I32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from a signed 32-bit integer input to a single-precision float value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_F32_U32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from an unsigned 32-bit integer input to a single-precision float value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_I32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_U32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from a single-precision float input to an unsigned 32-bit integer value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from a single-precision float input to a half-precision float value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_F32_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from a half-precision float input to a single-precision float value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_HI_F32_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert from a half-precision float value in the high 16 bits of a scalar input to a single-precision float value and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CEIL_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Round the half-precision float input up to next integer and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLOOR_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Round the half-precision float input down to previous integer and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_TRUNC_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Compute the integer part of a half-precision float input using round toward zero semantics and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_RNDNE_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Round the half-precision float input to the nearest even integer and store the result in floating point format into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_CO_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_CO_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_CO_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two signed 32-bit integer inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_CO_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the second signed 32-bit integer input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_CO_CI_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer inputs and a carry-in bit from SCC, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_CO_CI_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, subtract the carry-in bit, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT1_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_NOT1_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_NOT1_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_NOT1_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_HL_B32_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Add two floating point inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second floating point input from the first input and store the result in a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two floating point inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_FMAAK_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two floating point inputs and add a literal constant using fused multiply add, and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_FMAMK_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply a floating point input with a literal constant and add a second floating point input using fused multiply add, and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "OPR_SIMM32",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_FMAC_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Compute the fused multiply add of floating point inputs and accumulate with the destination operand, and store the result into the destination.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CVT_PK_RTZ_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Convert two single-precision float inputs into a packed half-precision float result using round toward zero semantics (ignore the current rounding mode), and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Add two floating point inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second floating point input from the first input and store the result in a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two half-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two half-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two floating point inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_FMAC_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Compute the fused multiply add of floating point inputs and accumulate with the destination operand, and store the result into the destination.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MINIMUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of two single-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAXIMUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of two single-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MINIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of two half-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAXIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of two half-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_NC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 64-bit integer inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_NC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the second unsigned 64-bit integer input from the first input and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply two unsigned 64-bit integer inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LE_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GE_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_O_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is orderable to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_O_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is orderable to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_U_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not orderable to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_U_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not orderable to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NGE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NGE_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NLG_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NLG_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NGT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NGT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NLE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NLE_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NEQ_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NEQ_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NLT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_NLT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set SCC to 1 iff the first scalar input is not less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_VERSION",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Do nothing. This opcode is used to specify the microcode version for tools that interpret shader microcode.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_ADDK_CO_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a scalar input and the sign extension of a literal 16-bit constant, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_SETHALT",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2"
    ],
    "description": "Set or clear the HALT or FATAL_HALT status bits.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SLEEP",
    "architectures": [
      "rdna4"
    ],
    "description": "Cause a wave to sleep for up to ~8000 clocks, or to sleep until an external event wakes the wave up.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CLAUSE",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Mark the beginning of a clause.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_DELAY_ALU",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Insert delay between dependent SALU/VALU instructions.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_ALU",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait for one or more ALU-centric counters to fall below specified values.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_IDLE",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna1"
    ],
    "description": "Wait for all activity in the wave to be complete (all dependency and memory counters at zero).",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_EVENT",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Wait for an event to occur or a condition to be satisfied before continuing. The SIMM16 argument specifies which event(s) to wait on.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_ROUND_MODE",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Set floating point round mode using an immediate constant.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_DENORM_MODE",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Set floating point denormal mode using an immediate constant.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_BARRIER_WAIT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait for a barrier to complete. The SIMM16 argument specifies which barrier to wait on.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CODE_END",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Generate an illegal instruction interrupt. This instruction is used to mark the end of a shader buffer for debug tools.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_SENDMSG",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Send a message to upstream control hardware.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_TTRACEDATA_IMM",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Send SIMM16[7:0] as user data to the thread trace stream.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_LOADCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until LOADCNT is less than or equal to SIMM16[5:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_STORECNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until STORECNT is less than or equal to SIMM16[5:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_SAMPLECNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until SAMPLECNT is less than or equal to SIMM16[5:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_BVHCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until BVHCNT is less than or equal to SIMM16[2:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_EXPCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until EXPCNT is less than or equal to SIMM16[2:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_DSCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until DSCNT is less than or equal to SIMM16[5:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_KMCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until KMCNT is less than or equal to SIMM16[4:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_LOADCNT_DSCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until LOADCNT is less than or equal to SIMM16[13:8] and DSCNT is less than or equal to SIMM16[5:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAIT_STORECNT_DSCNT",
    "architectures": [
      "rdna4"
    ],
    "description": "Wait until STORECNT is less than or equal to SIMM16[13:8] and DSCNT is less than or equal to SIMM16[5:0].",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the low 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 16 bits of data from the low 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 32 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 64 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 96 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 128 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 32 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 64 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 96 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 128 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_HI_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the high 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_HI_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 16 bits of data from the high 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_CLAMP_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer location in a buffer surface from a value in the data register and clamp the result to zero. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_I64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_I64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_COND_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value in the data register from a location in a buffer surface only if the memory value is greater than or equal to the data register value. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_PK_ADD_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component half-precision float value from the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component BF16 float value from the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_X",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 16 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_XY",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_XYZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_XYZW",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "RSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VBUFFER"
    ]
  },
  {
    "name": "DS_ADD_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SUB_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_RSUB_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in a location in a data share from a value stored in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_INC_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_DEC_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_AND_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_OR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_XOR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MSKOR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 32-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_2ADDR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from one vector input register and then 32 bits of data from a second vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_2ADDR_STRIDE64_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from one vector input register and then 32 bits of data from a second vector input register into a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_CMPSTORE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare an unsigned 32-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_ADD_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_ADD_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SUB_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_RSUB_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in a location in a data share from a value stored in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_INC_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_DEC_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_RTN_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_RTN_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_RTN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_AND_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_OR_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_XOR_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MSKOR_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 32-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STOREXCHG_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STOREXCHG_2ADDR_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap two unsigned 32-bit integer values in the data registers with two locations in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STOREXCHG_2ADDR_STRIDE64_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap two unsigned 32-bit integer values in the data registers with two locations in a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_CMPSTORE_RTN_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare an unsigned 32-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_NUM_RTN_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_NUM_RTN_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SWIZZLE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Dword swizzle, no data is written to LDS memory.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_2ADDR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from one location in a data share and then 32 bits of data from a second location in a data share and store the results into a 64-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_2ADDR_STRIDE64_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from one location in a data share and then 32 bits of data from a second location in a data share and store the results into a 64-bit vector register. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_I8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of signed data from a data share, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from a data share, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_CONSUME",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract (count_bits(exec_mask)) from the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_APPEND",
    "architectures": [
      "rdna4"
    ],
    "description": "Add (count_bits(exec_mask)) to the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_ADD_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SUB_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_RSUB_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in a location in a data share from a value stored in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_INC_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_DEC_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_I64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_I64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_AND_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_OR_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_XOR_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MSKOR_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 64-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_2ADDR_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from one vector input register and then 64 bits of data from a second vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_2ADDR_STRIDE64_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from one vector input register and then 64 bits of data from a second vector input register into a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_CMPSTORE_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare an unsigned 64-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_NUM_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two double-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_NUM_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two double-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_ADD_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SUB_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_RSUB_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in a location in a data share from a value stored in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_INC_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a data share with wraparound to 0 if the value exceeds a value in the data register. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_DEC_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a data share with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_RTN_I64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_RTN_I64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_RTN_U64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_AND_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_OR_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_XOR_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MSKOR_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate masked bitwise OR on an unsigned 64-bit integer location in a data share, given mask value and bits to OR in the data registers.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STOREXCHG_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STOREXCHG_2ADDR_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap two unsigned 64-bit integer values in the data registers with two locations in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STOREXCHG_2ADDR_STRIDE64_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap two unsigned 64-bit integer values in the data registers with two locations in a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_CMPSTORE_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare an unsigned 64-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MIN_NUM_RTN_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two double-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_MAX_NUM_RTN_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two double-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_2ADDR_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from one location in a data share and then 64 bits of data from a second location in a data share and store the results into a 128-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_2ADDR_STRIDE64_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from one location in a data share and then 64 bits of data from a second location in a data share and store the results into a 128-bit vector register. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_ADD_RTN_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_CONDXCHG32_RTN_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Perform 2 conditional write exchanges, where each conditional write exchange writes a 32 bit value from a data register to a location in data share iff the most significant bit of the data value is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_COND_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value in the data register from a location in a data share only if the memory value is greater than or equal to the data register value.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SUB_CLAMP_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer location in a data share from a value in the data register and clamp the result to zero.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_PK_ADD_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component half-precision float value from the data register to a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_PK_ADD_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component BF16 float value from the data register to a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B8_D16_HI",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from the high bits of a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B16_D16_HI",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from the high bits of a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_U8_D16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 16 bits and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_U8_D16_HI",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 16 bits and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_I8_D16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 16 bits and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_I8_D16_HI",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 16 bits and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_U16_D16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from a data share and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_U16_D16_HI",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from a data share and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_COND_SUB_RTN_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value in the data register from a location in a data share only if the memory value is greater than or equal to the data register value. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_SUB_CLAMP_RTN_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer location in a data share from a value in the data register and clamp the result to zero. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_PK_ADD_RTN_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component half-precision float value from the data register to a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_PK_ADD_RTN_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component BF16 float value from the data register to a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_ADDTID_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from a vector input register into a data share. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "DATA0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_ADDTID_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from a data share into a vector register. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_PERMUTE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Forward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave. It uses LDS to implement an arbitrary swizzle across threads in a wavefront.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_BPERMUTE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Backward permute. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave. It uses LDS hardware to implement an arbitrary swizzle across threads in a wavefront.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_BPERMUTE_FI_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Backward permute and fetch data for invalid lanes. This does not access LDS memory and may be called even if no LDS memory is allocated to the wave. It uses LDS hardware to implement an arbitrary swizzle across threads in a wavefront.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B96",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 96 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_STORE_B128",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 128 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_BVH_STACK_PUSH4_POP1_RTN_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Ray tracing involves traversing a BVH which is a kind of tree where nodes have up to 4 children. Each shader thread processes one child at a time, and overflow nodes are stored temporarily in LDS using a stack. This instruction supports pushing/popping the stack to reduce the number of VALU instructions required per traversal and reduce VMEM bandwidth requirements.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_BVH_STACK_PUSH8_POP1_RTN_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Ray tracing involves traversing a BVH which is a kind of tree where nodes have up to 4 children. Each shader thread processes one child at a time, and overflow nodes are stored temporarily in LDS using a stack. This instruction supports pushing/popping the stack to reduce the number of VALU instructions required per traversal and reduce VMEM bandwidth requirements.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_BVH_STACK_PUSH8_POP2_RTN_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Ray tracing involves traversing a BVH which is a kind of tree where nodes have up to 4 children. Each shader thread processes one child at a time, and overflow nodes are stored temporarily in LDS using a stack. This instruction supports pushing/popping the stack to reduce the number of VALU instructions required per traversal and reduce VMEM bandwidth requirements.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_B96",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 96 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_LOAD_B128",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VDS"
    ]
  },
  {
    "name": "DS_PARAM_LOAD",
    "architectures": [
      "rdna4"
    ],
    "description": "Transfer parameter data from LDS to VGPRs and expand data in LDS using the NewPrimMask (provided in M0) to place per-quad data into lanes 0-3 of each quad as follows:",
    "args": [
      "VDST",
      "ATTR"
    ],
    "arg_types": [
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_VDSDIR"
    ]
  },
  {
    "name": "DS_DIRECT_LOAD",
    "architectures": [
      "rdna4"
    ],
    "description": "Read a single 32-bit value from LDS to all lanes. A single DWORD is read from LDS memory at ADDR[M0[15:0]], where M0[15:0] is a byte address and is dword-aligned. M0[18:16] specify the data type for the read and may be 0=UBYTE, 1=USHORT, 2=DWORD, 4=SBYTE, 5=SSHORT.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_VDSDIR"
    ]
  },
  {
    "name": "EXPORT",
    "architectures": [
      "rdna4"
    ],
    "description": "Export graphics data to the next stage of the render pipeline. The target and up to four channels of data are specified as operands.",
    "args": [
      "TGT",
      "VSRC0",
      "VSRC1",
      "VSRC2",
      "VSRC3"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VEXPORT"
    ]
  },
  {
    "name": "FLAT_LOAD_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 32 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 64 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 96 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 128 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from a vector register into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from a vector register into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 32 bits of data from vector input registers into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 64 bits of data from vector input registers into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 96 bits of data from vector input registers into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 128 bits of data from vector input registers into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_HI_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_HI_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_D16_HI_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_STORE_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_CLAMP_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer location in the flat aperture from a value in the data register and clamp the result to zero. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_I64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_I64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_COND_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value in the data register from a location in the flat aperture only if the memory value is greater than or equal to the data register value. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_PK_ADD_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component half-precision float value from the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component BF16 float value from the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VFLAT"
    ]
  },
  {
    "name": "GLOBAL_LOAD_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 32 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 64 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 96 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 128 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from a vector register into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from a vector register into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 32 bits of data from vector input registers into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 64 bits of data from vector input registers into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 96 bits of data from vector input registers into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 128 bits of data from vector input registers into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_HI_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_HI_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_D16_HI_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_ADDTID_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from the global aperture into a vector register. The memory base address is provided in a scalar register and the lane ID is used as an offset.",
    "args": [
      "VDST",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_ADDTID_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 32 bits of data from a vector input register into the global aperture. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_INV",
    "architectures": [
      "rdna4"
    ],
    "description": "Invalidate cache lines based on the SCOPE field. Increments/decrements LOAD_CNT.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_WB",
    "architectures": [
      "rdna4"
    ],
    "description": "Write back dirty cache lines based on the SCOPE field. Increments/decrements STORE_CNT.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_CLAMP_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer location in the global aperture from a value in the data register and clamp the result to zero. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_I64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_I64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_U64",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_WBINV",
    "architectures": [
      "rdna4"
    ],
    "description": "Write back and invalidate cache lines based on the SCOPE field. Increments/decrements STORE_CNT.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_COND_SUB_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value in the data register from a location in the global aperture only if the memory value is greater than or equal to the data register value. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_BLOCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a block of data from the global aperture.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_BLOCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Store a block of data to the global aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_TR_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a 16x16 matrix of 16-bit data from the global aperture, transpose data between row-major and column-major order, and store the result into a 128-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_TR_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a 16x16 matrix of 8-bit data from the global aperture, transpose data between row-major and column-major order, and store the result into a 64-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component half-precision float value from the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component BF16 float value from the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ORDERED_ADD_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Given an (ID, value) pair in memory, increment the value by a given amount if the ID matches an ID provided by the shader.",
    "args": [
      "VDST",
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VGLOBAL"
    ]
  },
  {
    "name": "IMAGE_LOAD",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK_SGN",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK_SGN",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_STORE",
    "architectures": [
      "rdna4"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP",
    "architectures": [
      "rdna4"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_STORE_PCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_PCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SWAP",
    "architectures": [
      "rdna4"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_CMPSWAP",
    "architectures": [
      "rdna4"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in an image surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_ADD_UINT",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SUB_UINT",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_MIN_INT",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_MIN_UINT",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_MAX_INT",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_MAX_UINT",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_AND",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_OR",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_XOR",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_INC_UINT",
    "architectures": [
      "rdna4"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in an image surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_DEC_UINT",
    "architectures": [
      "rdna4"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in an image surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_GET_RESINFO",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather resource information for a given miplevel provided in the address register. Returns 4 integer values into registers 3:0 as { num_mip_levels, depth, height, width }. No memory access is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_BVH_INTERSECT_RAY",
    "architectures": [
      "rdna4"
    ],
    "description": "Test the intersection of rays with either box nodes or triangle nodes within a bounded volume hierarchy using 32 bit node pointers. Store the results of the test into a vector register. This instruction does not take a sampler constant.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_BVH64_INTERSECT_RAY",
    "architectures": [
      "rdna4"
    ],
    "description": "Test the intersection of rays with either box nodes or triangle nodes within a bounded volume hierarchy using 64 bit node pointers. Store the results of the test into a vector register. This instruction does not take a sampler constant.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_BVH_DUAL_INTERSECT_RAY",
    "architectures": [
      "rdna4"
    ],
    "description": "This instruction supports testing two QBVH nodes against the same ray per lane using both intersection engines. It is typically used to implement the BVH4x2 traversal algorithm.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_BVH8_INTERSECT_RAY",
    "architectures": [
      "rdna4"
    ],
    "description": "This instruction supports testing one BVH8 node against one ray per lane using both intersection engines.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_ADD_FLT",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_MIN_FLT",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_MAX_FLT",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_PK_ADD_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component half-precision float value from the data register to a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Add a packed 2-component BF16 float value from the data register to a location in an image surface. Store the original value from image surface into a vector register iff the temporal hint enables atomic return.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VIMAGE"
    ]
  },
  {
    "name": "V_INTERP_P10_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given the P10 parameter of an attribute, the I coordinate and the P0 parameter as single-precision float inputs, compute the first part of parameter interpolation and store the intermediate result into a vector register. Use V_INTERP_P2_F32 to complete the operation.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VINTERP"
    ]
  },
  {
    "name": "V_INTERP_P2_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given the P20 parameter of an attribute, the J coordinate and the result of a prior V_INTERP_P10_F32 instruction as single-precision float inputs, compute the second part of parameter interpolation and store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VINTERP"
    ]
  },
  {
    "name": "V_INTERP_P10_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a half-precision float P10 parameter of an attribute, a single-precision float I coordinate and a half-precision float P0 parameter as inputs, compute the first part of parameter interpolation and store the intermediate result in single-precision float format into a vector register. Use V_INTERP_P2_F16_F32 to complete the operation.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VINTERP"
    ]
  },
  {
    "name": "V_INTERP_P2_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a half-precision float P20 parameter of an attribute, a single-precision float J coordinate and the result of a prior V_INTERP_P10_F16_F32 instruction as inputs, compute the second part of parameter interpolation and store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VINTERP"
    ]
  },
  {
    "name": "V_INTERP_P10_RTZ_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a half-precision float P10 parameter of an attribute, a single-precision float I coordinate and a half-precision float P0 parameter as inputs, compute the first part of parameter interpolation using round toward zero semantics and store the intermediate result in single-precision float format into a vector register. Use V_INTERP_P2_RTZ_F16_F32 to complete the operation.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VINTERP"
    ]
  },
  {
    "name": "V_INTERP_P2_RTZ_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a half-precision float P20 parameter of an attribute, a single-precision float J coordinate and the result of a prior V_INTERP_P10_RTZ_F16_F32 instruction as inputs, compute the second part of parameter interpolation using round toward zero semantics and store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VINTERP"
    ]
  },
  {
    "name": "V_MOV_B32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Move 32-bit data from a vector input into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_READFIRSTLANE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Read the scalar value in the lowest active lane of the input vector register and store it into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_CVT_F32_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a signed 32-bit integer input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from an unsigned 32-bit integer input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_U32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a single-precision float input to an unsigned 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_I32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a single-precision float input to a half-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a half-precision float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_NEAREST_I32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value using round to nearest integer semantics (ignore the default rounding mode) and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_FLOOR_I32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value using round-down semantics (ignore the default rounding mode) and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_OFF_F32_I4",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a signed 4-bit integer input to a single-precision float value using an offset table and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE0",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert an unsigned byte in byte 0 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE1",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert an unsigned byte in byte 1 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE2",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert an unsigned byte in byte 2 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_UBYTE3",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert an unsigned byte in byte 3 of the input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_PIPEFLUSH",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Flush the vector ALU pipeline through the destination cache.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MOV_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Move 16-bit data from a vector input into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FRACT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the fractional portion of a single-precision float input and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_TRUNC_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the integer part of a single-precision float input using round toward zero semantics and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CEIL_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Round the single-precision float input up to next integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RNDNE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Round the single-precision float input to the nearest even integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FLOOR_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Round the single-precision float input down to previous integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_EXP_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate 2 raised to the power of the single-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LOG_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the base 2 logarithm of the single-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RCP_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the single-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RCP_IFLAG_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the vector float input in a manner suitable for integer division and store the result into a vector register. This opcode is intended for use as part of an integer division macro.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RSQ_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the square root of the single-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SQRT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the square root of the single-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SIN_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the trigonometric sine of a single-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_COS_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the trigonometric cosine of a single-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_NOT_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise negation on a vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_BFREV_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Reverse the order of bits in a vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CLZ_I32_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a vector input and store the result into a vector register. Store -1 if there are no \"1\" bits.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CTZ_I32_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a vector input and store the result into a vector register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CLS_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a vector input and store the result into a vector register. Store -1 if all input bits are the same.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FREXP_EXP_I32_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Extract the exponent of a single-precision float input and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FREXP_MANT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Extract the binary significand, or mantissa, of a single-precision float input and store the result as a single-precision float into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MOVRELD_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a vector input into a relatively-indexed vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MOVRELS_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a relatively-indexed vector register into another vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MOVRELSD_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a relatively-indexed vector register into another relatively-indexed vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MOVRELSD_2_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a relatively-indexed vector register into another relatively-indexed vector register, using different offsets for each index.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F16_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from an unsigned 16-bit integer input to a half-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F16_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a signed 16-bit integer input to a half-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_U16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a half-precision float input to an unsigned 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_I16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a half-precision float input to a signed 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RCP_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the half-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SQRT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the square root of the half-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RSQ_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the square root of the half-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LOG_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the base 2 logarithm of the half-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_EXP_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate 2 raised to the power of the half-precision float input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FREXP_MANT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Extract the binary significand, or mantissa, of a half-precision float input and store the result as a half-precision float into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FREXP_EXP_I16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Extract the exponent of a half-precision float input and store the result as a signed 16-bit integer into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FLOOR_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Round the half-precision float input down to previous integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CEIL_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Round the half-precision float input up to next integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_TRUNC_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the integer part of a half-precision float input using round toward zero semantics and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_RNDNE_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Round the half-precision float input to the nearest even integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FRACT_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the fractional portion of a half-precision float input and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SIN_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the trigonometric sine of a half-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_COS_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the trigonometric cosine of a half-precision float value using IEEE rules and store the result into a vector register. The operand is calculated by scaling the vector input by 2 PI.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SAT_PK_U8_I16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Given two 16-bit signed integer inputs, saturate each input over an 8-bit unsigned range, pack the resulting values into a 16-bit word and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_NORM_I16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a half-precision float input to a signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_NORM_U16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a half-precision float input to an unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SWAP_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap the values in two vector registers.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1"
    ]
  },
  {
    "name": "V_PERMLANE64_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform a specific permutation across lanes where the high half and low half of a wave64 are swapped. Performs no operation in wave32 mode.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "VOP1_INST_LITERAL"
    ]
  },
  {
    "name": "V_SWAPREL_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Swap the values in two relatively-indexed vector registers.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1"
    ]
  },
  {
    "name": "V_NOT_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise negation on a vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_I32_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from a signed 16-bit integer input to a signed 32-bit integer value using sign extension and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_U32_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from an unsigned 16-bit integer input to an unsigned 32-bit integer value using zero extension and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert from an FP8 float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_F32_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert from a BF8 float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CNDMASK_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Copy data from one of two inputs based on the per-lane condition code and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_F32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_F32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second floating point input from the first input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_F32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the first floating point input from the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_DX9_ZERO_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_F32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_I32_I24",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed 24-bit integer inputs and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_HI_I32_I24",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed 24-bit integer inputs and store the high 32 bits of the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_U32_U24",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_HI_U32_U24",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs and store the high 32 bits of the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_NUM_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX_NUM_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN_I32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_I32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_U32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_U32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHLREV_B32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHRREV_B32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ASHRREV_I32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_AND_B32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_OR_B32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_XOR_B32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_XNOR_B32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XNOR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHLREV_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_CO_CI_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Add two unsigned 32-bit integer inputs and a bit from a carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_CO_CI_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_CO_CI_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_NC_U32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_NC_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMAC_F32",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_RTZ_F16_F32",
    "architectures": [
      "rdna4",
      "rdna3"
    ],
    "description": "Convert two single-precision float inputs to a packed half-precision float value using round toward zero semantics (ignore the current rounding mode), and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_F16",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_F16",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second floating point input from the first input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_F16",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the first floating point input from the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_F16",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMAC_F16",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMAMK_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply a half-precision float input with a literal constant and add a second half-precision float input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "OPR_SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMAAK_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two half-precision float inputs and add a literal constant using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_LDEXP_F16",
    "architectures": [
      "rdna4",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_DX9_ZERO_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply and add single-precision values. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_I32_I24",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two signed 24-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from a third input, and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_U32_U24",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs in the unsigned 32-bit integer domain, add a unsigned 32-bit integer value from a third input, and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CUBEID_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the cubemap face ID of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CUBESC_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the cubemap S coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CUBETC_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the cubemap T coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CUBEMA_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the cubemap major axis coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_BFE_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset from the second input and size from the third input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_BFE_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Extract a signed bitfield from the first input using field offset from the second input and size from the third input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_BFI_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Overwrite a bitfield in the third input with a bitfield from the second input using a mask from the first input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two single-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_F64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two double-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LERP_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Average two 4-D vectors stored as packed bytes in the first two inputs with rounding control provided by the third input, then store the result into a vector register. Each byte in the third input acts as a rounding mode for the corresponding element; if the LSB is set then 0.5 rounds up, otherwise 0.5 truncates.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ALIGNBIT_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Align a 64-bit value encoded in the first two inputs to a bit position specified in the third input, then store the result into a 32-bit vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ALIGNBYTE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Align a 64-bit value encoded in the first two inputs to a byte position specified in the third input, then store the result into a 32-bit vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MULLIT_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register. Specific rules apply to accommodate lighting calculations: 0.0 * x = 0.0 and alternate INF, NAN, overflow rules apply.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the median of three signed 32-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the median of three unsigned 32-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SAD_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SAD_HI_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, shift the sum left by 16 bits, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SAD_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 2-component unsigned 16-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SAD_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the absolute difference of two unsigned 32-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_U8_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert a single-precision float value from the first input to an unsigned 8-bit integer value and pack the result into one byte of the third input using the second input as a byte select. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a single-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a double-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINIMUM3_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXIMUM3_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINIMUM3_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXIMUM3_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the median of three single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the median of three half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_DIV_FMAS_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two single-precision float inputs and add a third input using fused multiply add, then scale the exponent of the result by a fixed factor if the vector condition code is set. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FMAS_F64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two double-precision float inputs and add a third input using fused multiply add, then scale the exponent of the result by a fixed factor if the vector condition code is set. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MSAD_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, except that elements where the second input (known as the reference input) is zero are not included in the sum. Add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_QSAD_PK_U16_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform the V_SAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Truncate each result to 16 bits, pack the values into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 16-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MQSAD_PK_U16_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform the V_MSAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Truncate each result to 16 bits, pack the values into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 16-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MQSAD_U32_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform the V_MSAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Pack each 32-bit value into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 32-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_XOR3_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the bitwise XOR of three vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs, add an unsigned 16-bit integer value from a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_PERM_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Permute a 64-bit value constructed from two vector inputs (most significant bits come from the first input) using a per-lane selector from the third input. The lane selector allows each byte of the result to choose from any of the 8 input bytes, perform sign extension or pad with 0/1 bits. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_XAD_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR of the first two vector inputs, then add the third vector input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHL_ADD_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then add the third input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_LSHL_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add the first two integer inputs, then given a shift count in the third input, calculate the logical shift left of the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two half-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the median of three signed 16-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the median of three unsigned 16-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two signed 16-bit integer inputs, add a signed 16-bit integer value from a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a half-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD3_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add three unsigned inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHL_OR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then calculate the bitwise OR of the intermediate result and the third input, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_AND_OR_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on the first two vector inputs, then compute the bitwise OR of the intermediate result and the third vector input, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_OR3_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate the bitwise OR of three vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_U32_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from a third input, and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_I32_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two signed 16-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from a third input, and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_PERMLANE16_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform arbitrary gather-style operation within a row (16 contiguous lanes).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PERMLANEX16_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform arbitrary gather-style operation across two rows (each row is 16 contiguous lanes).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CNDMASK_B16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Copy data from one of two inputs based on the per-lane condition code and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXMIN_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of the first two unsigned 32-bit integer inputs and then select the minimum of that result and third unsigned 32-bit integer input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINMAX_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of the first two unsigned 32-bit integer inputs and then select the maximum of that result and third unsigned 32-bit integer input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXMIN_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of the first two signed 32-bit integer inputs and then select the minimum of that result and third signed 32-bit integer input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINMAX_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of the first two signed 32-bit integer inputs and then select the maximum of that result and third signed 32-bit integer input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_DOT2_F16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs, add the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_DOT2_BF16_BF16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 2-D BF16 float inputs, add the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINMAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of the first two single-precision float inputs and then select the IEEE maximumNumber() of that result and third single-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXMIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of the first two single-precision float inputs and then select the IEEE minimumNumber() of that result and third single-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINMAX_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of the first two half-precision float inputs and then select the IEEE maximumNumber() of that result and third half-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXMIN_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of the first two half-precision float inputs and then select the IEEE minimumNumber() of that result and third half-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINIMUMMAXIMUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of the first two single-precision float inputs and then select the IEEE maximum() of that result and third single-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXIMUMMINIMUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of the first two single-precision float inputs and then select the IEEE minimum() of that result and third single-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINIMUMMAXIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of the first two half-precision float inputs and then select the IEEE maximum() of that result and third half-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXIMUMMINIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of the first two half-precision float inputs and then select the IEEE minimum() of that result and third half-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_S_EXP_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate 2 raised to the power of the single-precision float input and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_EXP_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate 2 raised to the power of the half-precision float input and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_LOG_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the base 2 logarithm of the single-precision float input and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_LOG_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the base 2 logarithm of the half-precision float input and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_RCP_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the reciprocal of the single-precision float input using IEEE rules and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_RCP_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the reciprocal of the half-precision float input using IEEE rules and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_RSQ_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the reciprocal of the square root of the single-precision float input using IEEE rules and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_RSQ_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the reciprocal of the square root of the half-precision float input using IEEE rules and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_SQRT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the square root of the single-precision float input using IEEE rules and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_S_SQRT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Calculate the square root of the half-precision float input using IEEE rules and store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_SCALE_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a single-precision float value to scale in the first input, a denominator in the second input and a numerator in the third input, scale the first input for division if required to avoid subnormal terms appearing during application of the Newton-Raphson correction method. Store the scaled result into a vector register and set the vector condition code iff post-scaling is required.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_SCALE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a double-precision float value to scale in the first input, a denominator in the second input and a numerator in the third input, scale the first input for division if required to avoid subnormal terms appearing during application of the Newton-Raphson correction method. Store the scaled result into a vector register and set the vector condition code iff post-scaling is required.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_CO_U64_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply two unsigned integer inputs, add a third unsigned integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_CO_I64_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply two signed integer inputs, add a third signed integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_CO_U32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Add two unsigned 32-bit integer inputs, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_CO_U32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_CO_U32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_NC_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 16-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_U16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second unsigned 16-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_LO_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs and store the low bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_I16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert two single-precision float inputs into a packed signed 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_U16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert two single-precision float inputs into a packed unsigned 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_NC_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two signed 16-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_I16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second signed 16-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_PERMLANE16_VAR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Perform arbitrary gather-style operation within a row (16 contiguous lanes).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PERMLANEX16_VAR_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Perform arbitrary gather-style operation across two rows (each row is 16 contiguous lanes).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PACK_B32_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Pack two half-precision float values into a single 32-bit value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_NORM_I16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from two half-precision float inputs to a packed signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_NORM_U16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from two half-precision float inputs to a packed unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LDEXP_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_BFM_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_BCNT_U32_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Count the number of \"1\" bits in the vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MBCNT_LO_U32_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "For each lane 0 <= N < 32, examine the N least significant bits of the first input and count how many of those bits are \"1\". For each lane 32 <= N < 64, all \"1\" bits in the first input are counted. Add this count to the value in the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MBCNT_HI_U32_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "For each lane 32 <= N < 64, examine the N least significant bits of the first input and count how many of those bits are \"1\". For lane positions 0 <= N < 32 no bits are examined and the count is zero. Add this count to the value in the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_NORM_I16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from two single-precision float inputs to a packed signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_NORM_U16_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from two single-precision float inputs to a packed unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_U16_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from two unsigned 32-bit integer inputs to a packed unsigned 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_I16_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert from two signed 32-bit integer inputs to a packed signed 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_I32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Subtract the second signed 32-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_NC_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two signed 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LDEXP_F64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_LO_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned 32-bit integer inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_HI_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned 32-bit integer inputs and store the high 32 bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_HI_I32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two signed 32-bit integer inputs and store the high 32 bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_TRIG_PREOP_F64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Look up a 53-bit segment of 2/PI using an integer segment select in the second input. Scale the intermediate result by the exponent from the first double-precision float input and store the double-precision float result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LSHLREV_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHRREV_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ASHRREV_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHRREV_B64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ASHRREV_I64",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MINIMUM_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAXIMUM_F64",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_READLANE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Read the scalar value in the specified lane of the first input where the lane select is in the second input. Store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_WRITELANE_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Write the scalar value in the first input into the specified lane of a vector register where the lane select is in the second input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_AND_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_OR_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_XOR_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR on two vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINIMUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXIMUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimum() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximum() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_FP8_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert from two single-precision float inputs to a packed FP8 float value using round to nearest even semantics and store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_BF8_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert from two single-precision float inputs to a packed BF8 float value using round to nearest even semantics and store the result into 16 bits of a vector register using OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_SR_FP8_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert from a single-precision float input to an FP8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_SR_BF8_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Convert from a single-precision float input to a BF8 float value with stochastic rounding using seed data from the second input. Store the result into 8 bits of a vector register using OPSEL to determine which byte of the destination to overwrite.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_PK_MAD_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two packed signed 16-bit integer inputs component-wise, add a packed signed 16-bit integer value from a third input component-wise, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MUL_LO_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two packed unsigned 16-bit integer inputs component-wise and store the low bits of each resulting component into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ADD_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two packed signed 16-bit integer inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_SUB_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract the second packed signed 16-bit integer input from the first input component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_LSHLREV_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a packed shift count in the first vector input, calculate the component-wise logical shift left of the second packed vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_LSHRREV_B16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a packed shift count in the first vector input, calculate the component-wise logical shift right of the second packed vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ASHRREV_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a packed shift count in the first vector input, calculate the component-wise arithmetic shift right (preserving sign bit) of the second packed vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the component-wise maximum of two packed signed 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MIN_I16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the component-wise minimum of two packed signed 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAD_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two packed unsigned 16-bit integer inputs component-wise, add a packed unsigned 16-bit integer value from a third input component-wise, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ADD_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two packed unsigned 16-bit integer inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_SUB_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract the second packed unsigned 16-bit integer input from the first input component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the component-wise maximum of two packed unsigned 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MIN_U16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the component-wise minimum of two packed unsigned 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_FMA_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and add a third input component-wise using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ADD_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two packed half-precision float inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MUL_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT2_F32_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_DOT4_I32_IU8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 4-D unsigned 8-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4_U32_U8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 4-D unsigned 8-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT8_I32_IU4",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 8-D unsigned 4-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT8_U32_U4",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 8-D unsigned 4-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT2_F32_BF16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 2-D BF16 float inputs in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_PK_MIN_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the component-wise IEEE minimumNumber() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_NUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the component-wise IEEE maximumNumber() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MINIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the component-wise IEEE minimum() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAXIMUM_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the component-wise IEEE maximum() of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_MIX_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of half-precision float and single-precision float values. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_MIXLO_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of half-precision float and single-precision float values. Convert the result to a half-precision float. Store the result into the low bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_MIXHI_F16",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of half-precision float and single-precision float values. Convert the result to a half-precision float. Store the result into the high bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_DOT4_F32_FP8_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "Compute the dot product of a packed 4-D FP8 float input and a packed 4-D BF8 float input in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4_F32_BF8_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "Compute the dot product of a packed 4-D BF8 float input and a packed 4-D FP8 float input in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4_F32_FP8_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "Compute the dot product of two packed 4-D FP8 float inputs in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4_F32_BF8_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "Compute the dot product of two packed 4-D BF8 float inputs in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_WMMA_F32_16X16X16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_F32_16X16X16_BF16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_F16_16X16X16_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_BF16_16X16X16_BF16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_I32_16X16X16_IU8",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_I32_16X16X16_IU4",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_F32_16X16X16_FP8_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "WMMA matrix multiplication with 8-bit floating point inputs and 32-bit floating point result. Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_F32_16X16X16_FP8_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "WMMA matrix multiplication with 8-bit floating point inputs and 32-bit floating point result. Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_F32_16X16X16_BF8_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "WMMA matrix multiplication with 8-bit floating point inputs and 32-bit floating point result. Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_F32_16X16X16_BF8_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "WMMA matrix multiplication with 8-bit floating point inputs and 32-bit floating point result. Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_WMMA_I32_16X16X32_IU4",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register_or_inline"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F32_16X16X32_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F32_16X16X32_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F16_16X16X32_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_BF16_16X16X32_BF16",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_I32_16X16X32_IU8",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_I32_16X16X32_IU4",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_I32_16X16X64_IU4",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x64 matrix in the first input by the 64x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F32_16X16X32_FP8_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F32_16X16X32_FP8_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F32_16X16X32_BF8_FP8",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_SWMMAC_F32_16X16X32_BF8_BF8",
    "architectures": [
      "rdna4"
    ],
    "description": "Multiply the 16x32 matrix in the first input by the 32x16 matrix in the second input and accumulate the result into the 16x16 matrix in the destination registers using fused multiply add. Sparse indexes for the first matrix are given in the third input.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_CMP_LT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LG_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_O_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_U_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLG_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NEQ_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LG_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_O_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_U_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLG_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NEQ_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LG_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_O_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_U_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLG_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NEQ_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_CLASS_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_CLASS_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_CLASS_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LG_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_O_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_U_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLG_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLE_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLT_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LG_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_O_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_U_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLG_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLE_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLT_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LG_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_O_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_U_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLG_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLE_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLT_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_I32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_U32",
    "architectures": [
      "rdna4"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_I64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_U64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F16",
    "architectures": [
      "rdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F64",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_FMAC_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_FMAAK_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two single-precision float inputs and add a literal constant using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_FMAMK_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply a single-precision float input with a literal constant and add a second single-precision float input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "OPR_SIMM32",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_MUL_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_ADD_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_SUB_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract the second floating point input from the first input and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_SUBREV_F32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract the first floating point input from the second input and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_MUL_DX9_ZERO_F32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_MOV_B32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Move 32-bit data from a vector input into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_CNDMASK_B32",
    "architectures": [
      "rdna4",
      "rdna3.5"
    ],
    "description": "Copy data from one of two inputs based on the per-lane condition code and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_MAX_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE maximumNumber() of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_MIN_NUM_F32",
    "architectures": [
      "rdna4"
    ],
    "description": "Select the IEEE minimumNumber() of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_DOT2ACC_F32_F16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain and accumulate the resulting single-precision float value into the destination vector register. The initial value in D is used as S2.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_DOT2ACC_F32_BF16",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Dot product of packed brain-float values, accumulate with destination. The initial value in D is used as S2.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_ADD_NC_U32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDSTY",
      "SRCY0",
      "VSRCY1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_LSHLREV_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDSTY",
      "SRCY0",
      "VSRCY1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_AND_B32",
    "architectures": [
      "rdna4",
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND on two vector inputs and store the result into a vector register.",
    "args": [
      "VDSTY",
      "SRCY0",
      "VSRCY1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY",
      "VOPDXY_INST_LITERAL"
    ]
  },
  {
    "name": "IMAGE_MSAA_LOAD",
    "architectures": [
      "rdna4"
    ],
    "description": "Load up to 4 samples of 1 component from an MSAA resource with a user-specified fragment ID. No sampling is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_L",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_LZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_L",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_LZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_L_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_LZ_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_L_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_LZ_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_L",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_LZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_LZ",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_LZ_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_LZ_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GET_LOD",
    "architectures": [
      "rdna4"
    ],
    "description": "Return the calculated level of detail (LOD) for the provided input as two single-precision float values. No memory access is performed.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_O_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_O_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CL_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_CL_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CL_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_CL_O",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_O_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_O_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_G16",
    "architectures": [
      "rdna4"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_L",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_CL",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "IMAGE_GATHER4H",
    "architectures": [
      "rdna4"
    ],
    "description": "Gather 4 single-component texels from a 4x1 row vector on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1.",
    "args": [
      "VDATA",
      "OPR_VGPR",
      "RSRC",
      "SAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSAMPLE"
    ]
  },
  {
    "name": "SCRATCH_LOAD_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_U16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_I16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 32 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 64 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 96 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 128 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from a vector register into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from a vector register into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B32",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 32 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B64",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 64 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B96",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 96 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B128",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 128 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_HI_U8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_HI_I8",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_D16_HI_B8",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_D16_HI_B16",
    "architectures": [
      "rdna4"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_BLOCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Load a block of data from the scratch aperture.",
    "args": [
      "VDST",
      "VADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_BLOCK",
    "architectures": [
      "rdna4"
    ],
    "description": "Store a block of data to the scratch aperture.",
    "args": [
      "VADDR",
      "VSRC",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VSCRATCH"
    ]
  },
  {
    "name": "DS_CMPSTORE_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare a single-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_F32",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_GWS_SEMA_RELEASE_ALL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "GDS Only: The GWS resource (rid) indicated processes this opcode by updating the counter and labeling the specified resource as a semaphore.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_GWS_INIT",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "GDS Only: Initialize a barrier or semaphore resource.",
    "args": [
      "ADDR"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_GWS_SEMA_V",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "GDS Only: The GWS resource indicated processes this opcode by updating the counter and labeling the resource as a semaphore.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_GWS_SEMA_BR",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "GDS Only: The GWS resource indicated processes this opcode by updating the counter by the bulk release delivered count and labeling the resource as a semaphore.",
    "args": [
      "ADDR"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_GWS_SEMA_P",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "GDS Only: The GWS resource indicated processes this opcode by queueing it until counter enables a release and then decrementing the counter of the resource as a semaphore.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_GWS_BARRIER",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "GDS Only: The GWS resource indicated processes this opcode by queueing it until barrier is satisfied. The number of waves needed is passed in as DATA of first valid thread.",
    "args": [
      "ADDR"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPSTORE_RTN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare a single-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRAP_RTN_B32",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given a minuend from a location in data share and a subtrahend from a vector register, subtract the two values iff the result is nonnegative; otherwise add a value from a second vector register to the memory location.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CONSUME",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "LDS & GDS. Subtract (count_bits(exec_mask)) from the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_APPEND",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "LDS & GDS. Add (count_bits(exec_mask)) to the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ORDERED_COUNT",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "GDS-only: Intercepted by GDS and processed by ordered append module. The ordered append module queues request until this request wave is the oldest in the queue at which time the oldest wave request is dispatched to the DS with an atomic opcode indicated by OFFSET1[5:4].",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPSTORE_F64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare a double-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_F64",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_F64",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPSTORE_RTN_F64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare a double-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_F64",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_F64",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ADD_GS_REG_RTN",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform an atomic add to data in specific registers embedded in GDS rather than operating on GDS memory directly. This instruction returns the pre-op value. This instruction is only used by the GS stage and is used to facilitate streamout.",
    "args": [
      "VDST",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_SUB_GS_REG_RTN",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Perform an atomic subtraction from data in specific registers embedded in GDS rather than operating on GDS memory directly. This instruction returns the pre-op value. This instruction is only used by the GS stage and is used to facilitate streamout.",
    "args": [
      "VDST",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_BVH_STACK_RTN_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Ray tracing involves traversing a BVH which is a kind of tree where nodes have up to 4 children. Each shader thread processes one child at a time, and overflow nodes are stored temporarily in LDS using a stack. This instruction supports pushing/popping the stack to reduce the number of VALU instructions required per traversal and reduce VMEM bandwidth requirements.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "EXP",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Export graphics data to the next stage of the render pipeline. The target and up to four channels of data are specified as operands.",
    "args": [
      "TGT",
      "VSRC0",
      "VSRC1",
      "VSRC2",
      "VSRC3"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_EXP"
    ]
  },
  {
    "name": "FLAT_LOAD_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_U16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_I16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 96 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from a vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from a vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 96 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 128 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_HI_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_HI_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_D16_HI_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_I64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_I64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "GLOBAL_LOAD_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_U16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_I16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 96 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from a vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from a vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 96 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 128 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_HI_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_HI_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_D16_HI_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_STORE_ADDTID_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from a vector input register into the global aperture. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_ADDTID_B32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load dword, store results to LDS. No VGPR address is supplied in this instruction. TID is added to the address as shown below:",
    "args": [
      "SADDR"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_U8",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_I8",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_LDS_B32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CSUB_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 32-bit integer location in the global aperture from a value in the data register and clamp the result to zero. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_I64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_I64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLOBAL"
    ]
  },
  {
    "name": "SCRATCH_LOAD_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_U16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_I16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 96 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from a vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from a vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 96 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 128 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_HI_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_HI_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_D16_HI_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_U8",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_I8",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_LDS_B32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "LDS_PARAM_LOAD",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Transfer parameter data from LDS to VGPRs and expand data in LDS using the NewPrimMask (provided in M0) to place per-quad data into lanes 0-3 of each quad as follows:",
    "args": [
      "VDST",
      "ATTR"
    ],
    "arg_types": [
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_LDSDIR"
    ]
  },
  {
    "name": "LDS_DIRECT_LOAD",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Read a single 32-bit value from LDS to all lanes. A single DWORD is read from LDS memory at ADDR[M0[15:0]], where M0[15:0] is a byte address and is dword-aligned. M0[18:16] specify the data type for the read and may be 0=UBYTE, 1=USHORT, 2=DWORD, 4=SBYTE, 5=SSHORT.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_LDSDIR"
    ]
  },
  {
    "name": "IMAGE_LOAD",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK_SGN",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK_SGN",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_STORE",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_STORE_PCK",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_PCK",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SWAP",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_CMPSWAP",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in an image surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_ADD",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SUB",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SMIN",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_UMIN",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SMAX",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_UMAX",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_AND",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_OR",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_XOR",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_INC",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in an image surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_DEC",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in an image surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GET_RESINFO",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather resource information for a given miplevel provided in the address register. Returns 4 integer values into registers 3:0 as { num_mip_levels, depth, height, width }. No memory access is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_MSAA_LOAD",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load up to 4 samples of 1 component from an MSAA resource with a user-specified fragment ID. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_BVH_INTERSECT_RAY",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Test the intersection of rays with either box nodes or triangle nodes within a bounded volume hierarchy using 32 bit node pointers. Store the results of the test into a vector register. This instruction does not take a sampler constant.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_BVH64_INTERSECT_RAY",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Test the intersection of rays with either box nodes or triangle nodes within a bounded volume hierarchy using 64 bit node pointers. Store the results of the test into a vector register. This instruction does not take a sampler constant.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_L",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_LZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_L",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_LZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_L_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_LZ_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_L_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_LZ_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_L",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_LZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_LZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_LZ_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_LZ_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GET_LOD",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Return the calculated level of detail (LOD) for the provided input as two single-precision float values. No memory access is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_O_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_O_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CL_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_CL_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CL_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_CL_O",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_O_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_O_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_G16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_L",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_CL",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "IMAGE_GATHER4H",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 4x1 row vector on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_D16_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 16 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_D16_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "cdna1"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the low 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 16 bits of data from the low 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_XY",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_XYZ",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_FORMAT_XYZW",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_U16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_I16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 32 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 64 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 96 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 128 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 32 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 64 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_B96",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 96 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_B128",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 128 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_U8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_I8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_HI_B8",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_HI_B16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_D16_HI_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the high 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_D16_HI_FORMAT_X",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Convert 16 bits of data from the high 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_GL0_INV",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Write back and invalidate the shader L0. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_GL1_INV",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Invalidate the GL1 cache only. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_LDS_U8",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_LDS_I8",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_LDS_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_LDS_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_LDS_B32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load data, zero/sign extend and store in LDS destination.",
    "args": [
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_LDS_FORMAT_X",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Untyped buffer load 1 dword with format conversion, store in LDS destination.",
    "args": [
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CSUB_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 32-bit integer location in a buffer surface from a value in the data register and clamp the result to zero. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_B32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_I64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_I64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_U64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two single-precision float values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "S_GL1_INV",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Invalidate the GL1 cache only.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_MIN_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Select the minimum of two single-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Select the maximum of two single-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Select the minimum of two half-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Select the maximum of two half-precision float inputs and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_WAITCNT_VSCNT",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Wait for the VSCNT counter to be at or below the specified level. The VSCNT counter tracks the number of outstanding vector memory stores and atomics that do not return data. This counter is not used in 'all-in-order' mode.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_WAITCNT_VMCNT",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Wait for the VMCNT counter to be at or below the specified level. The VMCNT counter tracks the number of outstanding vector memory loads and atomics that do return data. When in 'all-in-order' mode, wait for all load and store vector memory events.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_WAITCNT_EXPCNT",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Wait for the EXPCNT counter to be at or below the specified level. The EXPCNT counter tracks the number of outstanding export events.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_WAITCNT_LGKMCNT",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Wait for the LGKMCNT counter to be at or below the specified level. The LGKMCNT counter tracks the number of outstanding local data share (L), global data share (G), scalar memory (K) and message (M) events.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_SET_INST_PREFETCH_DISTANCE",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Change instruction prefetch mode. This controls how many cachelines ahead of the current PC the shader attempts to prefetch.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_WAITCNT_DEPCTR",
    "architectures": [
      "rdna3.5",
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Wait for one or more ALU-centric counters to fall below specified values. Used in expert scheduling mode.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "V_DOT2ACC_F32_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain and accumulate the resulting single-precision float value into the destination vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMAC_DX9_ZERO_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two single-precision values and accumulate the result with the destination. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_DX9_ZERO_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_F32",
    "architectures": [
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_F32",
    "architectures": [
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHLREV_B32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_LSHRREV_B32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ASHRREV_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_CO_CI_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Add two unsigned 32-bit integer inputs and a bit from a carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_CO_CI_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_CO_CI_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_NC_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Add two unsigned 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Subtract the second unsigned 32-bit integer input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_NC_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Subtract the first unsigned 32-bit integer input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PK_RTZ_F16_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Convert two single-precision float inputs to a packed half-precision float value using round toward zero semantics (ignore the current rounding mode), and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Subtract the first floating point input from the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMAC_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_F16",
    "architectures": [
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_F16",
    "architectures": [
      "rdna3.5",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the median of three single-precision float values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN3_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX3_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MED3_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the median of three half-precision float values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXMIN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of the first two single-precision float inputs and then select the minimum of that result and third single-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINMAX_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of the first two single-precision float inputs and then select the maximum of that result and third single-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAXMIN_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of the first two half-precision float inputs and then select the minimum of that result and third half-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MINMAX_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of the first two half-precision float inputs and then select the maximum of that result and third half-precision float input. Store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAD_U64_U32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two unsigned integer inputs, add a third unsigned integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_I64_I32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two signed integer inputs, add a third signed integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_F64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Add two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_F64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN_F64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX_F64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LSHLREV_B64",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MIN_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the component-wise minimum of two packed half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_F16",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the component-wise maximum of two packed half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LG_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_O_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_U_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLG_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NEQ_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LG_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_O_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_U_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLG_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NEQ_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_F64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_F64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_I64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_I64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_U64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_U64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_CLASS_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_CLASS_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the per-lane condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LG_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_O_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_U_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLG_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLE_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLT_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LG_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_O_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_U_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLG_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLE_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLT_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_F64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_F64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_I16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_U16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_I32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_U32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_I64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_I64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_U64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_U64",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Set the per-lane condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F16",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F32",
    "architectures": [
      "rdna3.5"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the per-lane condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_DUAL_MAX_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the maximum of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY"
    ]
  },
  {
    "name": "V_DUAL_MIN_F32",
    "architectures": [
      "rdna3.5",
      "rdna3"
    ],
    "description": "Select the minimum of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY"
    ]
  },
  {
    "name": "S_ADD_U32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_U32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_I32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two signed inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_I32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second signed input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADDC_U32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned inputs and a carry-in bit, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUBB_U32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, subtract the carry-in bit, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_I32",
    "architectures": [
      "rdna3",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two signed integers and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_WAIT_EVENT",
    "architectures": [
      "rdna3"
    ],
    "description": "Wait for an event to occur or a condition to be satisfied before continuing. The SIMM16 argument specifies which event(s) to wait on.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "V_MOV_B32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a vector input into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SAT_PK_U8_I16",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Given two 16-bit unsigned integer inputs, saturate each input over an 8-bit unsigned range, pack the resulting values into a 16-bit word and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CNDMASK_B32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_DOT2ACC_F32_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain and accumulate the resulting single-precision float value into the destination vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8"
    ]
  },
  {
    "name": "V_MUL_DX9_ZERO_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_F32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_F32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_CO_CI_U32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned inputs and a bit from a carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_CO_CI_U32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask to a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_CO_CI_U32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the first unsigned input from the second input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask to a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "VSRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_U32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_NC_U32",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the first unsigned input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MAX_F16",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_MIN_F16",
    "architectures": [
      "rdna3",
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_CNDMASK_B16",
    "architectures": [
      "rdna3"
    ],
    "description": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_ADD_CO_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Add two unsigned inputs, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_CO_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Subtract the second unsigned input from the first input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUBREV_CO_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Subtract the first unsigned input from the second input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL",
      "VOP3_SDST_ENC_VOP_DPP16",
      "VOP3_SDST_ENC_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_SUB_NC_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_MIX_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of 16-bit and 32-bit floating point values. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_MIXLO_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of 16-bit and 32-bit floating point values. Convert the result to a half-precision float. Store the result into the low bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_MIXHI_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of 16-bit and 32-bit floating point values. Convert the result to a half-precision float. Store the result into the high bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL",
      "VOP3P_VOP_DPP16",
      "VOP3P_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LG_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_O_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_U_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLG_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NEQ_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LG_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_O_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_U_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLG_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NGT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NEQ_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NLT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LG_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_O_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_U_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLG_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NEQ_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LT_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_EQ_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_LE_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GT_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_NE_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_GE_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_T_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_F_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_CLASS_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_CLASS_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "OPR_VCC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMP_CLASS_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LG_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_O_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_U_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLG_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLE_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLT_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LG_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_O_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_U_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLG_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NGT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLE_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NLT_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LG_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_O_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_U_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLG_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLE_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLT_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_I16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_U16",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_I32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LT_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_EQ_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_LE_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GT_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_NE_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_GE_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_T_U32",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_F_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_I64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_U64",
    "architectures": [
      "rdna3"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F16",
    "architectures": [
      "rdna3"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the vector condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the vector condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOP3_VOP_DPP16",
      "VOP3_VOP_DPP8",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_DPP16",
      "VOPC_VOP_DPP8"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F64",
    "architectures": [
      "rdna3"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the vector condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_DUAL_MUL_DX9_ZERO_F32",
    "architectures": [
      "rdna3"
    ],
    "description": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY"
    ]
  },
  {
    "name": "V_DUAL_MOV_B32",
    "architectures": [
      "rdna3"
    ],
    "description": "Move data from a vector input into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY"
    ]
  },
  {
    "name": "V_DUAL_CNDMASK_B32",
    "architectures": [
      "rdna3"
    ],
    "description": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.",
    "args": [
      "VDSTX",
      "SRCX0",
      "VSRCX1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "VOPDXY"
    ]
  },
  {
    "name": "DS_WRITE_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from one vector input register and then 32 bits of data from a second vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2ST64_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from one vector input register and then 32 bits of data from a second vector input register into a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare an unsigned 32-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_F32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare a single-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B8",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG_RTN_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2_RTN_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap two unsigned 32-bit integer values in the data registers with two locations in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2ST64_RTN_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap two unsigned 32-bit integer values in the data registers with two locations in a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare an unsigned 32-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_F32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare a single-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from one location in a data share and then 32 bits of data from a second location in a data share and store the results into a 64-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2ST64_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from one location in a data share and then 32 bits of data from a second location in a data share and store the results into a 64-bit vector register. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I8",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U8",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of signed data from a data share, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from a data share, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_ORDERED_COUNT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "GDS-only. Add (count_bits(exec_mask)) to one of 4 dedicated ordered-count counters (aka 'packers'). Additional bits of instr.offset field are overloaded to hold packer-id, 'last'.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 64 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 64 bits of data from one vector input register and then 64 bits of data from a second vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE2ST64_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 64 bits of data from one vector input register and then 64 bits of data from a second vector input register into a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare an unsigned 64-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare a double-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG_RTN_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2_RTN_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap two unsigned 64-bit integer values in the data registers with two locations in a data share.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRXCHG2ST64_RTN_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap two unsigned 64-bit integer values in the data registers with two locations in a data share. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare an unsigned 64-bit integer value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CMPST_RTN_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare a double-precision float value in the data comparison register with a location in a data share, and modify the memory location with a value in the data source register if the comparison is equal.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0",
      "DATA1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 64 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 64 bits of data from one location in a data share and then 64 bits of data from a second location in a data share and store the results into a 128-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ2ST64_B64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 64 bits of data from one location in a data share and then 64 bits of data from a second location in a data share and store the results into a 128-bit vector register. Treat each offset as an index and multiply by a stride of 64 elements (256 bytes) to generate an offset for each DS address.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B8_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from the high bits of a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B16_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from the high bits of a vector register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U8_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 16 bits and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U8_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from a data share, zero extend to 16 bits and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I8_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 16 bits and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_I8_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from a data share, sign extend to 16 bits and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U16_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from a data share and store the result into the low 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_U16_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from a data share and store the result into the high 16 bits of a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_ADDTID_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from a vector input register into a data share. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "DATA0"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_ADDTID_B32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from a data share into a vector register. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B96",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 96 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_WRITE_B128",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 128 bits of data from a vector input register into a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B96",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 96 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_READ_B128",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 128 bits of data from a data share into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "FLAT_LOAD_UBYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SBYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_USHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SSHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of signed data from the flat aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 64 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 128 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 96 bits of data from the flat aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_BYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from a vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_BYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_SHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from a vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 64 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 128 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_STORE_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 96 bits of data from vector input registers into the flat aperture.",
    "args": [
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_UBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_UBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the flat aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the flat aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SHORT_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_LOAD_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the flat aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMIN",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMIN",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMAX",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMAX",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_FCMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_FMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_FMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_FCMPSWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two double-precision float values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_FMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_FMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "GLOBAL_LOAD_UBYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SBYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_USHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SSHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of signed data from the global aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 64 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 128 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 96 bits of data from the global aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_DWORD_ADDTID",
    "architectures": [
      "rdna2"
    ],
    "description": "Load 32 bits of data from the global aperture into a vector register. The memory base address is provided in a scalar register and the lane ID is used as an offset.",
    "args": [
      "VDST",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORD_ADDTID",
    "architectures": [
      "rdna2"
    ],
    "description": "Store 32 bits of data from a vector input register into the global aperture. The memory base address is provided as an immediate value and the lane ID is used as an offset.",
    "args": [
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_BYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from a vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_BYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_SHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from a vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 64 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 128 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_STORE_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 96 bits of data from vector input registers into the global aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_UBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_UBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the global aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the global aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SHORT_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_LOAD_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the global aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CSUB",
    "architectures": [
      "rdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer location in the global aperture from a value in the data register and clamp the result to zero. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMIN",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMIN",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMAX",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMAX",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_FCMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_FMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_FMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_X2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_FCMPSWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two double-precision float values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_FMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_FMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "SCRATCH_LOAD_UBYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SBYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_USHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SSHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of signed data from the scratch aperture, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 32 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 64 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 128 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 96 bits of data from the scratch aperture into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_BYTE",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from a vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_BYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_SHORT",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from a vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORD",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 32 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 64 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 128 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_STORE_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Store 96 bits of data from vector input registers into the scratch aperture.",
    "args": [
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_UBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_UBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from the scratch aperture, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from the scratch aperture, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SHORT_D16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "SCRATCH_LOAD_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from the scratch aperture and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDST",
      "ADDR",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_SCRATCH"
    ]
  },
  {
    "name": "IMAGE_LOAD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK_SGN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK_SGN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_PCK",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_PCK",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GET_RESINFO",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather resource information for a given miplevel provided in the address register. Returns 4 integer values into registers 3:0 as { num_mip_levels, depth, height, width }. No memory access is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_CMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in an image surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_ADD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SUB",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_UMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_UMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_AND",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_OR",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_XOR",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_INC",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in an image surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_DEC",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in an image surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_FCMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in an image surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_FMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_FMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_L",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_LZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_L",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_LZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_L_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_B_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_LZ_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_L_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_B_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_LZ_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_BY2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2 horizontal elements from the largest miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. Illegal for formats with more than 2 components. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_BY4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4 horizontal elements from the largest miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. Illegal for formats with more than 1 component. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_L",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_LZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_BY2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2 horizontal elements from a user-specified miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. Illegal for formats with more than 2 components. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_BY4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4 horizontal elements from a user-specified miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. Illegal for formats with more than 1 component. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_L",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_LZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_BY2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 2 horizontal elements from a vector register to the largest miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage. Illegal for formats with more than 2 components.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_BY4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 4 horizontal elements from a vector register to the largest miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage. Illegal for formats with more than 1 component.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_L_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_LZ_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_BY2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 2 horizontal elements from a vector register to a user-specified miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage. Illegal for formats with more than 2 components.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_BY4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 4 horizontal elements from a vector register to a user-specified miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage. Illegal for formats with more than 1 component.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_L_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_LZ_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, user offsets are provided by the address registers. Mipmap level is set to zero.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GET_LOD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Return the calculated level of detail (LOD) for the provided input as two single-precision float values. No memory access is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4H",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather 4 single-component texels from a 4x1 row vector on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER4H_PCK",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather all components of 4 texels from a 4x1 row vector on an image surface. Store the result into vector registers. The DMASK selects how many channels to write.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_GATHER8H_PCK",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Gather all components of 8 texels from a 8x1 row vector on an image surface. Store the result into vector registers. The DMASK selects how many channels to write.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_CL",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_CL_O",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2 horizontal elements from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. Illegal for element sizes greater than 64 bits. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4 horizontal elements from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. Illegal for element sizes greater than 32 bits. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2 horizontal elements from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. Illegal for element sizes greater than 64 bits. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4 horizontal elements from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. Illegal for element sizes greater than 32 bits. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_PCK2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 2 horizontal elements from a vector register to the largest miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored. Illegal for element sizes greater than 64 bits.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_PCK4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 4 horizontal elements from a vector register to the largest miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored. Illegal for element sizes greater than 32 bits.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_PCK2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 2 horizontal elements from a vector register to a user-specified miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored. Illegal for element sizes greater than 64 bits.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_PCK4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 4 horizontal elements from a vector register to a user-specified miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored. Illegal for element sizes greater than 32 bits.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_MSAA_LOAD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load up to 4 samples of 1 component from an MSAA resource with a user-specified fragment ID. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_D_CL_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_D_CL_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_BVH_INTERSECT_RAY",
    "architectures": [
      "rdna2"
    ],
    "description": "Test the intersection of rays with either box nodes or triangle nodes within a bounded volume hierarchy using 32 bit node pointers. Store the results of the test into a vector register. This instruction does not take a sampler constant.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_BVH64_INTERSECT_RAY",
    "architectures": [
      "rdna2"
    ],
    "description": "Test the intersection of rays with either box nodes or triangle nodes within a bounded volume hierarchy using 64 bit node pointers. Store the results of the test into a vector register. This instruction does not take a sampler constant.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_CL_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_CL_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, LOD clamp, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_CL_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_CL_O_G16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, LOD clamp, user offsets, 16-bit derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MIMG",
      "MIMG_NSA1",
      "MIMG_NSA2",
      "MIMG_NSA3"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 16 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to 32 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 96 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 128 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_USHORT",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SSHORT",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 16 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 32 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 64 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 128 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 96 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_BYTE",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 8 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_BYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_SHORT",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 16 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 32 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 64 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 128 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX3",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Store 96 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE_D16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SHORT_D16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SHORT_D16_HI",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_HI_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the high 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_HI_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 16 bits of data from the high 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CSUB",
    "architectures": [
      "rdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer location in a buffer surface from a value in the data register and clamp the result to zero. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_FCMPSWAP",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two single-precision float values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_FMIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_FMAX",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_FCMPSWAP_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compare two double-precision float values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_FMIN_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_FMAX_X2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the low 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_X",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 16 bits of data from the low 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XY",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XYZ",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XYZW",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "S_LOAD_DWORD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 32 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 64 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 128 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 256 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_LOAD_DWORDX16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 512 bits of data from the scalar memory into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORD",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 32 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX2",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 64 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 128 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 256 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_LOAD_DWORDX16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Load 512 bits of data from a scalar buffer surface into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_MOV_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Move scalar input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOV_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Move scalar input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMOV_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Move scalar input into a scalar register iff SCC is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMOV_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Move scalar input into a scalar register iff SCC is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOT_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise negation on a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOT_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise negation on a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_WQM_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given an active pixel mask in a scalar input, calculate whole quad mode mask for that input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_WQM_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given an active pixel mask in a scalar input, calculate whole quad mode mask for that input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BREV_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Reverse the order of bits in a scalar input and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BREV_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Reverse the order of bits in a scalar input and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT0_I32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of \"0\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT0_I32_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of \"0\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT1_I32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of \"1\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BCNT1_I32_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of \"1\" bits in a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF0_I32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of trailing \"1\" bits before the first \"0\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"0\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF0_I32_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of trailing \"1\" bits before the first \"0\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"0\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF1_I32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FF1_I32_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a scalar input and store the result into a scalar register. Store -1 if there are no \"1\" bits.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a scalar register. Store -1 if all input bits are the same.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_FLBIT_I32_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a scalar input and store the result into a scalar register. Store -1 if all input bits are the same.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_SEXT_I32_I8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sign extend a signed 8 bit scalar input to 32 bits and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_SEXT_I32_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Sign extend a signed 16 bit scalar input to 32 bits and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET0_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 0.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET0_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 0.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET1_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 1.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITSET1_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a bit offset in a scalar input, set the indicated bit in the destination scalar register to 1.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_QUADMASK_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Reduce a pixel mask from the scalar input into a quad mask, store the result in a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_QUADMASK_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Reduce a pixel mask from the scalar input into a quad mask, store the result in a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOVRELD_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a scalar input into a relatively-indexed scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_MOVRELD_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Move data from a scalar input into a relatively-indexed scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ABS_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the absolute value of a scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN1_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN1_SAVEEXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN1_WREXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_WREXEC_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITREPLICATE_B64_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Substitute each bit of a 32 bit scalar input with two instances of itself and store the result into a 64 bit scalar register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NAND on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XNOR on the scalar input and the EXEC mask, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN1_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN1_SAVEEXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask, set SCC iff the calculated result is nonzero and store the original value of the EXEC mask into the scalar destination register.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN1_WREXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the EXEC mask and the negation of the scalar input, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_WREXEC_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the scalar input and the negation of the EXEC mask, store the calculated result into the EXEC mask and also into the scalar destination register, and set SCC iff the calculated result is nonzero.",
    "args": [
      "SDST",
      "SSRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP1",
      "SOP1_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADD_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two signed inputs, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUB_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second signed input from the first input, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ADDC_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned inputs and a carry-in bit, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_SUBB_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, subtract the carry-in bit, store the result into a scalar register and store the carry-out bit into SCC.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MIN_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MAX_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, store the selected value into a scalar register and set SCC iff the first value is selected.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CSELECT_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the first input if SCC is true otherwise select the second input, then store the selected input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CSELECT_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the first input if SCC is true otherwise select the second input, then store the selected input into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_AND_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_OR_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XOR_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR on two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ANDN2_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ORN2_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise OR with the first input and the negation of the second input, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NAND on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NAND_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NAND on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_NOR_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise NOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XNOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_XNOR_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XNOR on two scalar inputs, store the result into a scalar register and set SCC if the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift left of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift left of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift right of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHR_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the logical shift right of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ASHR_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the arithmetic shift right (preserving sign bit) of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ASHR_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second scalar input, calculate the arithmetic shift right (preserving sign bit) of the first scalar input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFM_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result in a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFM_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result in a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed integers and store the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a signed bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_BFE_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a signed bitfield from the first input using field offset and size encoded in the second input, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_ABSDIFF_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the absolute value of difference between two scalar inputs, store the result into a scalar register and set SCC iff the result is nonzero.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL1_ADD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 1, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL2_ADD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 2, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL3_ADD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 3, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_LSHL4_ADD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the logical shift left of the first input by 4, then add the second input, store the result into a scalar register and set SCC iff the summation results in an unsigned overflow.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_LL_B32_B16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_LH_B32_B16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_PACK_HH_B32_B16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Pack two 16-bit scalar values into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_HI_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned integers and store the high 32 bits of the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_MUL_HI_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed integers and store the high 32 bits of the result into a scalar register.",
    "args": [
      "SDST",
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOP2",
      "SOP2_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GT_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_GE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is greater than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LT_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP0_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 0.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP1_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 1.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP0_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 0.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_BITCMP1_B64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a bit from the first scalar input based on an index in the second scalar input, and set SCC to 1 iff the extracted bit is equal to 1.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_EQ_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is equal to the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_CMP_LG_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set SCC to 1 iff the first scalar input is less than or greater than the second scalar input.",
    "args": [
      "SSRC0",
      "SSRC1"
    ],
    "arg_types": [
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_SOPC",
      "SOPC_INST_LITERAL"
    ]
  },
  {
    "name": "S_VERSION",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Perform no operation. This opcode is used to specify the microcode version for tools that interpret shader microcode.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "special"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_SUBVECTOR_LOOP_BEGIN",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Begin execution of a subvector block of code.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "label"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_SUBVECTOR_LOOP_END",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "End execution of a subvector block of code.",
    "args": [
      "SDST",
      "SIMM16"
    ],
    "arg_types": [
      "register",
      "label"
    ],
    "available_encodings": [
      "ENC_SOPK"
    ]
  },
  {
    "name": "S_INST_PREFETCH",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Change instruction prefetch mode. This controls how many cachelines ahead of the current PC the shader attempts to prefetch.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "S_CLAUSE",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Mark the beginning of a clause.",
    "args": [
      "SIMM16"
    ],
    "arg_types": [
      "immediate"
    ],
    "available_encodings": [
      "ENC_SOPP"
    ]
  },
  {
    "name": "V_INTERP_P1_F32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given the I coordinate in a vector register and an attribute specifier, load parameter data from the local data share, compute the first part of parameter interpolation and store the intermediate result into a vector register. Use V_INTERP_P2_F32 to complete the operation.",
    "args": [
      "VDST",
      "VSRC",
      "ATTR"
    ],
    "arg_types": [
      "register",
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_VINTRP",
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_INTERP_P2_F32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given the J coordinate in a vector register, an attribute specifier and the result of a prior V_INTERP_P1_F32 in the destination vector register, load parameter data from the local data share, compute the second part of parameter interpolation and store the final result into a vector register.",
    "args": [
      "VDST",
      "VSRC",
      "ATTR"
    ],
    "arg_types": [
      "register",
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_VINTRP",
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_INTERP_MOV_F32",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given an attribute specifier and a parameter ID (P0, P10 or P20), load one of the parameter values from the local data share into a vector register.",
    "args": [
      "VDST",
      "VSRC",
      "ATTR"
    ],
    "arg_types": [
      "register",
      "unknown",
      "special"
    ],
    "available_encodings": [
      "ENC_VINTRP",
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_READFIRSTLANE_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Read the scalar value in the lowest active lane of the input vector register and store it into a scalar register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_I32_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a double-precision float input to a signed 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_RPI_I32_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value using round to nearest integer semantics (ignore the default rounding mode) and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP1_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_FLR_I32_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a single-precision float input to a signed 32-bit integer value using round-down semantics (ignore the default rounding mode) and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP1_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_F32_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a double-precision float input to a single-precision float value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_U32_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from a double-precision float input to an unsigned 32-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_TRUNC_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the integer part of a double-precision float input using round toward zero semantics and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CEIL_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Round the double-precision float input up to next integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_RNDNE_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Round the double-precision float input to the nearest even integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FLOOR_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Round the double-precision float input down to previous integer and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_RCP_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the double-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_RSQ_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the reciprocal of the square root of the double-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SQRT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the square root of the double-precision float input using IEEE rules and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FFBH_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of leading \"0\" bits before the first \"1\" in a vector input and store the result into a vector register. Store -1 if there are no \"1\" bits.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP1_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FFBL_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of trailing \"0\" bits before the first \"1\" in a vector input and store the result into a vector register. Store -1 if there are no \"1\" bits in the input.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP1_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FFBH_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of leading bits that are the same as the sign bit of a vector input and store the result into a vector register. Store -1 if all input bits are the same.",
    "args": [
      "VDST",
      "VSRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP16",
      "VOP1_VOP_DPP8",
      "VOP1_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FREXP_EXP_I32_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract the exponent of a double-precision float input and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FREXP_MANT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract the binary significand, or mantissa, of a double-precision float input and store the result as a double-precision float into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FRACT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the fractional portion of a double-precision float input and store the result in floating point format into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT2C_F32_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain and accumulate the resulting single-precision float value into the destination vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMAC_LEGACY_F32",
    "architectures": [
      "rdna2"
    ],
    "description": "Multiply two single-precision values and accumulate the result with the destination. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_LEGACY_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP2_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4C_I32_I8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 4-D signed 8-bit integer inputs in the signed 32-bit integer domain and accumulate the resulting signed 32-bit integer value into the destination vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8"
    ]
  },
  {
    "name": "V_CVT_PKRTZ_F16_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert two single-precision float inputs to a packed half-precision float value using round toward zero semantics (ignore the current rounding mode), and store the result into a vector register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP2_VOP_SDWA",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_FMAC_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and accumulate the result into the destination register using fused multiply add.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8"
    ]
  },
  {
    "name": "V_FMA_LEGACY_F32",
    "architectures": [
      "rdna2"
    ],
    "description": "Multiply and add single-precision values. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_I32_I24",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed 24-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from a third input, and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_U32_U24",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 24-bit integer inputs in the unsigned 32-bit integer domain, add a unsigned 32-bit integer value from a third input, and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CUBEID_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the cubemap face ID of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CUBESC_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the cubemap S coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CUBETC_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the cubemap T coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CUBEMA_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the cubemap major axis coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_BFE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract an unsigned bitfield from the first input using field offset from the second input and size from the third input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_BFE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Extract a signed bitfield from the first input using field offset from the second input and size from the third input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_BFI_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Overwrite a bitfield in the third input with a bitfield from the second input using a mask from the first input, then store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two double-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LERP_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Average two 4-D vectors stored as packed bytes in the first two inputs with rounding control provided by the third input, then store the result into a vector register. Each byte in the third input acts as a rounding mode for the corresponding element; if the LSB is set then 0.5 rounds up, otherwise 0.5 truncates.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ALIGNBIT_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Align a 64-bit value encoded in the first two inputs to a bit position specified in the third input, then store the result into a 32-bit vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ALIGNBYTE_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Align a 64-bit value encoded in the first two inputs to a byte position specified in the third input, then store the result into a 32-bit vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MULLIT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and store the result into a vector register. Specific rules apply to accommodate lighting calculations: 0.0 * x = 0.0 and alternate INF, NAN, overflow rules apply.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX3_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of three single-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX3_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of three signed 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX3_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of three unsigned 32-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MED3_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the median of three single-precision float values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MED3_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the median of three signed 32-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MED3_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the median of three unsigned 32-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SAD_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SAD_HI_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, shift the sum left by 16 bits, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SAD_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 2-component unsigned 16-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SAD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the absolute difference of two unsigned 32-bit integer inputs, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PK_U8_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert a single-precision float value from the first input to an unsigned 8-bit integer value and pack the result into one byte of the third input using the second input as a byte select. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a single-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a double-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two double-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_LO_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 32-bit integer inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_HI_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 32-bit integer inputs and store the high 32 bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_HI_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed 32-bit integer inputs and store the high 32 bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_SCALE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a single-precision float value to scale in the first input, a denominator in the second input and a numerator in the third input, scale the first input for division if required to avoid subnormal terms appearing during application of the Newton-Raphson correction method. Store the scaled result into a vector register and set the vector condition code iff post-scaling is required.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_SCALE_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a double-precision float value to scale in the first input, a denominator in the second input and a numerator in the third input, scale the first input for division if required to avoid subnormal terms appearing during application of the Newton-Raphson correction method. Store the scaled result into a vector register and set the vector condition code iff post-scaling is required.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FMAS_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a third input using fused multiply add, then scale the exponent of the result by a fixed factor if the vector condition code is set. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FMAS_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two double-precision float inputs and add a third input using fused multiply add, then scale the exponent of the result by a fixed factor if the vector condition code is set. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MSAD_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the sum of absolute differences of elements in two packed 4-component unsigned 8-bit integer inputs, except that elements where the second input (known as the reference input) is zero are not included in the sum. Add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_QSAD_PK_U16_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Perform the V_SAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Truncate each result to 16 bits, pack the values into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 16-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MQSAD_PK_U16_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Perform the V_MSAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Truncate each result to 16 bits, pack the values into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 16-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MQSAD_U32_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Perform the V_MSAD_U8 operation four times using different slices of the first array, all entries of the second array and each entry of the third array. Pack each 32-bit value into a 4-entry array and store the array into a vector register. The first input is an 8-entry array of unsigned 8-bit integers, the second input is a 4-entry array of unsigned 8-bit integers and the third input is a 4-entry array of unsigned 32-bit integers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_U64_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned integer inputs, add a third unsigned integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_I64_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed integer inputs, add a third signed integer input, store the result into a 64-bit vector register and store the overflow/carryout into a scalar mask register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_XOR3_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the bitwise XOR of three vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_NC_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned 16-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SUB_NC_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MUL_LO_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs and store the low bits of the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LSHRREV_B16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift right of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ASHRREV_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the arithmetic shift right (preserving sign bit) of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of two signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of two signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_NC_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two signed 16-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SUB_NC_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_CO_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two unsigned inputs, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_SUB_CO_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_PACK_B32_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Pack two half-precision float values into a single 32-bit value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PKNORM_I16_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from two half-precision float inputs to a packed signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PKNORM_U16_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from two half-precision float inputs to a packed unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LSHLREV_B16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the first vector input, calculate the logical shift left of the second vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SUBREV_CO_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the first unsigned input from the second input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "SDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3_SDST_ENC",
      "VOP3_SDST_ENC_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs, add an unsigned 16-bit integer value from a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_INTERP_P1LL_F16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given a single-precision float I coordinate in a vector register and an attribute specifier, load two half-precision float parameter values from the local data share, compute the first part of parameter interpolation and store the intermediate result into a vector register. Use V_INTERP_P2_F16 to complete the operation.",
    "args": [
      "VDST",
      "SRC1",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register",
      "special"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_INTERP_P1LV_F16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given a single-precision float I coordinate in a vector register, a half-precision float P0 value in another vector register, and an attribute specifier, load a half-precision float parameter value from the local data share, compute the first part of parameter interpolation and store the intermediate result into a vector register. Use V_INTERP_P2_F16 to complete the operation.",
    "args": [
      "VDST",
      "SRC1",
      "SRC0",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "special",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PERM_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Permute a 64-bit value constructed from two vector inputs (most significant bits come from the first input) using a per-lane selector from the third input. The lane selector allows each byte of the result to choose from any of the 8 input bytes, perform sign extension or pad with 0/1 bits. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_XAD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise XOR of the first two vector inputs, then add the third vector input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LSHL_ADD_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then add the third input to the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_LSHL_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add the first two integer inputs, then given a shift count in the third input, calculate the logical shift left of the intermediate result, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two half-precision float inputs and add a third input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MIN3_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the minimum of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX3_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of three half-precision float inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX3_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of three signed 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAX3_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the maximum of three unsigned 16-bit integer inputs and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MED3_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the median of three half-precision float values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MED3_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the median of three signed 16-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MED3_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the median of three unsigned 16-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_INTERP_P2_F16",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna1"
    ],
    "description": "Given a single-precision float J coordinate in a vector register, an attribute specifier and the result of a prior V_INTERP_P1_F32 in another vector register, load a half-precision float parameter value from the local data share, compute the second part of parameter interpolation and store the final result as a half-precision float value into a vector register.",
    "args": [
      "VDST",
      "SRC1",
      "SRC0",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "special",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed 16-bit integer inputs, add a signed 16-bit integer value from a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_DIV_FIXUP_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a half-precision float quotient in the first input, a denominator in the second input and a numerator in the third input, detect and apply corner cases related to division, including divide by zero, NaN inputs and overflow, and modify the quotient accordingly. Generate any invalid, denormal and divide-by-zero exceptions that are a result of the division. Store the modified quotient into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_READLANE_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Read the scalar value in the specified lane of the first input where the lane select is in the second input. Store the result into a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LDEXP_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply the first input, a floating point value, by an integral power of 2 specified in the second input, a signed integer value, and store the floating point result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_BFM_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate a bitfield mask given a field offset and size and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_BCNT_U32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Count the number of \"1\" bits in the vector input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MBCNT_LO_U32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "For each lane 0 <= N < 32, examine the N least significant bits of the first input and count how many of those bits are \"1\". For each lane 32 <= N < 64, all \"1\" bits in the first input are counted. Add this count to the value in the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MBCNT_HI_U32_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "For each lane 32 <= N < 64, examine the N least significant bits of the first input and count how many of those bits are \"1\". For lane positions 0 <= N < 32 no bits are examined and the count is zero. Add this count to the value in the second input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PKNORM_I16_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from two single-precision float inputs to a packed signed normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PKNORM_U16_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from two single-precision float inputs to a packed unsigned normalized short and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PK_U16_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from two unsigned 32-bit integer inputs to a packed unsigned 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_CVT_PK_I16_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Convert from two signed 32-bit integer inputs to a packed signed 16-bit integer value and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD3_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add three unsigned inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_LSHL_OR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Given a shift count in the second input, calculate the logical shift left of the first input, then calculate the bitwise OR of the intermediate result and the third input, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_AND_OR_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate bitwise AND on the first two vector inputs, then compute the bitwise OR of the intermediate result and the third vector input, then store the final result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_OR3_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Calculate the bitwise OR of three vector inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_U32_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two unsigned 16-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from a third input, and store the result as an unsigned 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_I32_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two signed 16-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from a third input, and store the result as a signed 32-bit integer into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_SUB_NC_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PERMLANE16_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Perform arbitrary gather-style operation within a row (16 contiguous lanes).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PERMLANEX16_B32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Perform arbitrary gather-style operation across two rows (each row is 16 contiguous lanes).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_NC_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two signed 32-bit integer inputs and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAD_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two packed signed 16-bit integer inputs component-wise, add a packed signed 16-bit integer value from a third input component-wise, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MUL_LO_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two packed unsigned 16-bit integer inputs component-wise and store the low bits of each resulting component into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ADD_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two packed signed 16-bit integer inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_SUB_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second packed signed 16-bit integer input from the first input component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the component-wise maximum of two packed signed 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MIN_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the component-wise minimum of two packed signed 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAD_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two packed unsigned 16-bit integer inputs component-wise, add a packed unsigned 16-bit integer value from a third input component-wise, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ADD_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two packed unsigned 16-bit integer inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_SUB_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Subtract the second packed unsigned 16-bit integer input from the first input component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the component-wise maximum of two packed unsigned 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MIN_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the component-wise minimum of two packed unsigned 16-bit integer inputs and store the selected values into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_FMA_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and add a third input component-wise using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_ADD_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Add two packed half-precision float inputs component-wise and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MUL_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two packed half-precision float inputs component-wise and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MIN_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the component-wise minimum of two packed half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_PK_MAX_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Select the component-wise maximum of two packed half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT2_F32_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 2-D half-precision float inputs in the single-precision float domain, add a single-precision float value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT2_I32_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 2-D signed 16-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT2_U32_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 2-D unsigned 16-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4_I32_I8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 4-D signed 8-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT4_U32_U8",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 4-D unsigned 8-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT8_I32_I4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 8-D signed 4-bit integer inputs in the signed 32-bit integer domain, add a signed 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_DOT8_U32_U4",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Compute the dot product of two packed 8-D unsigned 4-bit integer inputs in the unsigned 32-bit integer domain, add an unsigned 32-bit integer value from the third input and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_MIX_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of 16-bit and 32-bit floating point values. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_MIXLO_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of 16-bit and 32-bit floating point values. Convert the result to a half-precision float. Store the result into the low bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMA_MIXHI_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Multiply two inputs and add a third input using fused multiply add where the inputs are a mix of 16-bit and 32-bit floating point values. Convert the result to a half-precision float. Store the result into the high bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P",
      "VOP3P_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LG_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_O_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_U_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLG_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NEQ_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_TRU_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LG_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_O_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_U_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLG_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLE_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLT_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_TRU_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LG_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_O_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_U_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGE_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLG_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NGT_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLE_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NEQ_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NLT_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_TRU_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LG_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_O_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_U_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGE_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLG_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLE_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLT_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_TRU_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_CLASS_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_CLASS_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_I32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the vector condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_I16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the vector condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_I64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_CLASS_F64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_I64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the vector condition code to the result. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_U16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LG_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_O_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_U32",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LG_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_O_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LT_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_EQ_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_LE_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GT_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_NE_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_GE_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_T_U64",
    "architectures": [
      "rdna2",
      "rdna1",
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_U_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLG_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NEQ_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_TRU_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "SDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_U64",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_U_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLG_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLE_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLT_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_TRU_F16",
    "architectures": [
      "rdna2",
      "rdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask.",
    "args": [
      "OPR_EXEC",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOP3_INST_LITERAL",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "S_SCRATCH_LOAD_DWORD",
    "architectures": [
      "rdna1"
    ],
    "description": "Load 32 bits of data from the scalar scratch aperture into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_LOAD_DWORDX2",
    "architectures": [
      "rdna1"
    ],
    "description": "Load 64 bits of data from the scalar scratch aperture into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_SCRATCH_LOAD_DWORDX4",
    "architectures": [
      "rdna1"
    ],
    "description": "Load 128 bits of data from the scalar scratch aperture into a scalar register.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATC_PROBE",
    "architectures": [
      "rdna1"
    ],
    "description": "Probe or prefetch an address into the scalar data cache.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATC_PROBE_BUFFER",
    "architectures": [
      "rdna1"
    ],
    "description": "Probe or prefetch an address into the scalar data cache.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "immediate",
      "unknown",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_GET_WAVEID_IN_WORKGROUP",
    "architectures": [
      "rdna1"
    ],
    "description": "Return the wave's ID within a workgroup 0-(N-1). Return zero if wave is not in a workgroup. ID reflects the order in which waves were created within each workgroup.",
    "args": [
      "SDATA"
    ],
    "arg_types": [
      "register"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "V_MAC_LEGACY_F32",
    "architectures": [
      "rdna1"
    ],
    "description": "Multiply and add single-precision values, accumulate with destination. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAC_F32",
    "architectures": [
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register.",
    "args": [
      "VDST",
      "VSRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP16",
      "VOP2_VOP_DPP8",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MADMK_F32",
    "architectures": [
      "rdna1"
    ],
    "description": "Multiply a floating point input with a literal constant and add a second floating point input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "OPR_SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_MADAK_F32",
    "architectures": [
      "rdna1"
    ],
    "description": "Multiply two floating point inputs and add a literal constant, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "OPR_SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_LEGACY_F32",
    "architectures": [
      "rdna1"
    ],
    "description": "Multiply and add single-precision values. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_F32",
    "architectures": [
      "rdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "VOP3_INST_LITERAL"
    ]
  },
  {
    "name": "DS_MIN_I32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_I32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_U32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_U32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_I32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_I32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_U32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_U32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two single-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_I64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_I64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_U64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_U64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a data share.",
    "args": [
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_I64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_I64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_U64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_U64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MIN_RTN_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_MAX_RTN_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two double-precision float inputs, given two values stored in the data register and a location in a data share. Store the original value from data share into a vector register.",
    "args": [
      "VDST",
      "ADDR",
      "DATA0"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_CONSUME",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "LDS & GDS. Subtract (count_bits(exec_mask)) from the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "DS_APPEND",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "LDS & GDS. Add (count_bits(exec_mask)) to the value stored in DS memory at (M0.base + instr_offset). Return the pre-operation value to VGPRs.",
    "args": [
      "VDST"
    ],
    "arg_types": [
      "unknown"
    ],
    "available_encodings": [
      "ENC_DS"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMIN",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMIN",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMAX",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMAX",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_F32",
    "architectures": [
      "cdna3"
    ],
    "description": "Add a single-precision float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna3"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a double-precision float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MIN_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum signed integer value given the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_MAX_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum signed integer value given the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "cdna3"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the flat aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_ADD_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SUB_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_AND_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_OR_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_XOR_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the flat aperture. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_INC_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the flat aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "FLAT_ATOMIC_DEC_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the flat aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from flat aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_FLAT"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMIN",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMIN",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMAX",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMAX",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a single-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a double-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MIN_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum signed integer value given the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_MAX_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum signed integer value given the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_BF16",
    "architectures": [
      "cdna3"
    ],
    "description": "Add a packed 2-component BF16 float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in the global aperture. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SUB_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_AND_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_OR_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_XOR_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_INC_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in the global aperture with wraparound to 0 if the value exceeds a value in the data register. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_DEC_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in the global aperture with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "unknown",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a single-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add a double-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MIN_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum signed integer value given the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_MAX_F64",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum signed integer value given the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_X2",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "S_DCACHE_INV",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Invalidate the scalar (L0) data cache.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_WB",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Write back dirty data in the scalar (L0) data cache.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_INV_VOL",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Invalidate the scalar (L0) data cache volatile lines.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_WB_VOL",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Write back dirty data in the scalar (L0) data cache volatile lines.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_DISCARD",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Discard one dirty scalar (L0) data cache line. A cache line is 64 bytes.",
    "args": [
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_DCACHE_DISCARD_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Discard two consecutive dirty scalar (L0) data cache lines. A cache line is 64 bytes.",
    "args": [
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMIN",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMIN",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMAX",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMAX",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_BUFFER_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a scalar buffer surface.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMIN",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMIN",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMAX",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMAX",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "S_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in the scalar memory.",
    "args": [
      "SDATA",
      "SBASE",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "ENC_SMEM"
    ]
  },
  {
    "name": "V_MOV_B32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Move data from a vector input into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_SAT_PK_U8_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Given two 16-bit unsigned integer inputs, saturate each input over an 8-bit unsigned range, pack the resulting values into a 16-bit word and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0"
    ],
    "arg_types": [
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP1",
      "ENC_VOP3",
      "VOP1_INST_LITERAL",
      "VOP1_VOP_DPP",
      "VOP1_VOP_SDWA"
    ]
  },
  {
    "name": "V_CNDMASK_B32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Copy data from one of two inputs based on the vector condition code and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_FMAMK_F32",
    "architectures": [
      "cdna3"
    ],
    "description": "Multiply a single-precision float input with a literal constant and add a second single-precision float input using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_FMAAK_F32",
    "architectures": [
      "cdna3"
    ],
    "description": "Multiply two single-precision float inputs and add a literal constant using fused multiply add, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_ADD_CO_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned inputs, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUB_CO_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUBREV_CO_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the first unsigned input from the second input, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_ADDC_CO_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Add two unsigned inputs and a bit from a carry-in mask, store the result into a vector register and store the carry-out mask into a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUBB_CO_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second unsigned input from the first input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask to a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_SUBBREV_CO_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the first unsigned input from the second input, subtract a bit from the carry-in mask, store the result into a vector register and store the carry-out mask to a scalar register.",
    "args": [
      "VDST",
      "OPR_VCC",
      "SRC0",
      "VSRC1",
      "OPR_VCC"
    ],
    "arg_types": [
      "register",
      "register",
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA_SDST_ENC",
      "VOP3_SDST_ENC"
    ]
  },
  {
    "name": "V_MADMK_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply a floating point input with a literal constant and add a second floating point input, and store the result into a vector register. Implements IEEE rules and non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_MADAK_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and add a literal constant, and store the result into a vector register. Implements IEEE rules and non-standard rule for OPSEL.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_SUB_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUBREV_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the first unsigned input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUB_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second unsigned input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_SUBREV_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the first unsigned input from the second input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_CUBEMA_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Compute the cubemap major axis coordinate of a 3D coordinate specified as three single-precision float inputs. Store the result in single-precision float format into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the median of three single-precision float values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the median of three signed 32-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the median of three unsigned 32-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the median of three half-precision float values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the median of three signed 16-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MED3_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the median of three unsigned 16-bit integer values and store the selected value into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SUB_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_SUB_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Subtract the second signed input from the first input and store the result into a vector register. No carry-in or carry-out support.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MUL_LEGACY_F32",
    "architectures": [
      "cdna3",
      "cdna2"
    ],
    "description": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_PK_MIN_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the component-wise minimum of two packed half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_PK_MAX_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Select the component-wise maximum of two packed half-precision float inputs and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MAD_MIX_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two inputs and add a third input where the inputs are a mix of 16-bit and 32-bit floating point values. Store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MAD_MIXLO_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two inputs and add a third input where the inputs are a mix of 16-bit and 32-bit floating point values. Convert the result to a half-precision float. Store the result into the low bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MAD_MIXHI_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two inputs and add a third input where the inputs are a mix of 16-bit and 32-bit floating point values. Convert the result to a half-precision float. Store the result into the high bits of a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3P"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X8_XF32",
    "architectures": [
      "cdna3"
    ],
    "description": "Multiply the 16x8 matrix in the first input by the 8x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X4_XF32",
    "architectures": [
      "cdna3"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_CMP_CLASS_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a single-precision float, and set the vector condition code to the result. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a double-precision float, and set the vector condition code to the result. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_CLASS_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the vector condition code to the result. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_CLASS_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Evaluate the IEEE numeric class function specified as a 10 bit mask in the second input on the first input, a half-precision float, and set the vector condition code to the result. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LG_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_O_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_U_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLG_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NEQ_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_TRU_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LG_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_O_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_U_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLG_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLE_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLT_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_TRU_F16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LG_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_O_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_U_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLG_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NGT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NEQ_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NLT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_TRU_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LG_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_O_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_U_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLG_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NGT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLE_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NLT_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_TRU_F32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LG_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_O_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_U_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not orderable to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGE_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLG_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NGT_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLE_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NEQ_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NLT_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_TRU_F64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMP_F_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_I16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_U16",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_F_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LT_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_EQ_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_LE_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GT_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_NE_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_GE_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMP_T_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_I32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LT_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_EQ_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_LE_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GT_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_NE_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_GE_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_T_U32",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL",
      "VOPC_VOP_SDWA_SDST_ENC"
    ]
  },
  {
    "name": "V_CMPX_F_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_I64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_F_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 0. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LT_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_EQ_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_LE_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is less than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GT_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_NE_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is not equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_GE_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1 iff the first input is greater than or equal to the second input. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "V_CMPX_T_U64",
    "architectures": [
      "cdna3",
      "cdna2",
      "cdna1"
    ],
    "description": "Set the vector condition code to 1. Store the result into the EXEC mask and to VCC or a scalar register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3",
      "ENC_VOPC",
      "VOPC_INST_LITERAL"
    ]
  },
  {
    "name": "IMAGE_LOAD",
    "architectures": [
      "cdna2"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP",
    "architectures": [
      "cdna2"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. Perform the format conversion specified by the resource descriptor. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK",
    "architectures": [
      "cdna2"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_LOAD_PCK_SGN",
    "architectures": [
      "cdna2"
    ],
    "description": "Load a texel from the largest miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK",
    "architectures": [
      "cdna2"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are zero-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_LOAD_MIP_PCK_SGN",
    "architectures": [
      "cdna2"
    ],
    "description": "Load a texel from a user-specified miplevel in an image surface and store the result into a vector register. 8- and 16-bit components are sign-extended. The format specified in the resource descriptor is ignored. No sampling is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_STORE",
    "architectures": [
      "cdna2"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP",
    "architectures": [
      "cdna2"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is converted using the format conversion specified by the resource descriptor prior to storage.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_STORE_PCK",
    "architectures": [
      "cdna2"
    ],
    "description": "Store a texel from a vector register to the largest miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_STORE_MIP_PCK",
    "architectures": [
      "cdna2"
    ],
    "description": "Store a texel from a vector register to a user-specified miplevel in an image surface. The texel data is already packed and the format specified in the resource descriptor is ignored.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GET_RESINFO",
    "architectures": [
      "cdna2"
    ],
    "description": "Gather resource information for a given miplevel provided in the address register. Returns 4 integer values into registers 3:0 as { num_mip_levels, depth, height, width }. No memory access is performed.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SWAP",
    "architectures": [
      "cdna2"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna2"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in an image surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_ADD",
    "architectures": [
      "cdna2"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SUB",
    "architectures": [
      "cdna2"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SMIN",
    "architectures": [
      "cdna2"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_UMIN",
    "architectures": [
      "cdna2"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_SMAX",
    "architectures": [
      "cdna2"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_UMAX",
    "architectures": [
      "cdna2"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_AND",
    "architectures": [
      "cdna2"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_OR",
    "architectures": [
      "cdna2"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_XOR",
    "architectures": [
      "cdna2"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in an image surface. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_INC",
    "architectures": [
      "cdna2"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in an image surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_ATOMIC_DEC",
    "architectures": [
      "cdna2"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in an image surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from image surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE",
    "architectures": [
      "cdna2"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. This is the only sample instruction supported on this ASIC.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "unknown",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "BUFFER_INVL2",
    "architectures": [
      "cdna2"
    ],
    "description": "Invalidate L2 cache. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_LDS_DWORD",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Store one DWORD from LDS memory to system memory without utilizing VGPRs.",
    "args": [
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_WBINVL1",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Write back and invalidate the shader L1. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_WBINVL1_VOL",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Write back and invalidate the shader L1 only for lines that are marked volatile. Returns ACK to shader.",
    "args": [],
    "arg_types": [],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "V_MAC_F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and accumulate the result into the destination register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP"
    ]
  },
  {
    "name": "V_MADMK_F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply a floating point input with a literal constant and add a second floating point input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SIMM32",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "immediate",
      "register"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_MADAK_F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and add a literal constant, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1",
      "SIMM32"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "immediate"
    ],
    "available_encodings": [
      "VOP2_INST_LITERAL"
    ]
  },
  {
    "name": "V_MAD_LEGACY_F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply and add single-precision values. Follows DX9 rules where 0.0 times anything produces 0.0.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MAD_F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply two single-precision float inputs and add a third input, and store the result into a vector register.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X1F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x1 matrix in the first input by the 1x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X1F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x1 matrix in the first input by the 1x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X1F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 4x1 matrix in the first input by the 1x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X2F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x2 matrix in the first input by the 2x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X4F32",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X4F16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X4F16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X4F16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X8F16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x8 matrix in the first input by the 8x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X16F16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_32X32X4I8",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_16X16X4I8",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_4X4X4I8",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_32X32X8I8",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x8 matrix in the first input by the 8x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_I32_16X16X16I8",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X4BF16_1K",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X4BF16_1K",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X4BF16_1K",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X8BF16_1K",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 32x8 matrix in the first input by the 8x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X16BF16_1K",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 16x16 matrix in the first input by the 16x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X2BF16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x2 matrix in the first input by the 2x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X2BF16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x2 matrix in the first input by the 2x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_4X4X2BF16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 4x2 matrix in the first input by the 2x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_32X32X4BF16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 32x4 matrix in the first input by the 4x32 matrix in the second input and add the 32x32 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F32_16X16X8BF16",
    "architectures": [
      "cdna2",
      "cdna1"
    ],
    "description": "Multiply the 16x8 matrix in the first input by the 8x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F64_16X16X4F64",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 16x4 matrix in the first input by the 4x16 matrix in the second input and add the 16x16 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "V_MFMA_F64_4X4X4F64",
    "architectures": [
      "cdna2"
    ],
    "description": "Multiply the 4x4 matrix in the first input by the 4x4 matrix in the second input and add the 4x4 matrix in the third input using fused multiply add. Store the resulting matrix into vector registers.",
    "args": [
      "VDST",
      "SRC0",
      "SRC1",
      "SRC2"
    ],
    "arg_types": [
      "unknown",
      "unknown",
      "unknown",
      "unknown"
    ],
    "available_encodings": [
      "VOP3P_MFMA"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_ADD_F32",
    "architectures": [
      "cdna1"
    ],
    "description": "Add a single-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "GLOBAL_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna1"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in the global aperture. Store the original value from global aperture into a vector register iff the GLC bit is set.",
    "args": [
      "VDST",
      "ADDR",
      "DATA",
      "SADDR"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_FLAT_GLBL"
    ]
  },
  {
    "name": "IMAGE_GATHER4H_PCK",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather all components of 4 texels from a 4x1 row vector on an image surface. Store the result into vector registers. The DMASK selects how many channels to write.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER8H_PCK",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather all components of 8 texels from a 8x1 row vector on an image surface. Store the result into vector registers. The DMASK selects how many channels to write.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_CL_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_L_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_B_CL_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_CL_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_L_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_GATHER4_C_B_CL_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Gather 4 single-component texels from a 2x2 matrix on an image surface. Store the result into vector registers. The DMASK selects which channel to read from (R, G, B, A) and must only have one bit set to 1. Additional data for PCF, LOD bias, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_CL",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_CL",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, LOD clamp are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_CD_CL_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for coarse derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "IMAGE_SAMPLE_C_CD_CL_O",
    "architectures": [
      "cdna1"
    ],
    "description": "Sample texels from an image surface using texel coordinates provided by the address input registers and store the result into vector registers. Additional data for PCF, coarse derivatives, LOD clamp, user offsets are provided by the address registers.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SSAMP"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_MIMG"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_X",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XY",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XYZ",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_LOAD_FORMAT_D16_XYZW",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_X",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 16 bits of data from vector input registers into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XY",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XYZ",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "TBUFFER_STORE_FORMAT_D16_XYZW",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MTBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_X",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the low 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XY",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 2-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XYZ",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 3-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_XYZW",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 4-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into a vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_X",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 16 bits of data from the low 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XY",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 32 bits of data from vector input registers into 2-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XYZ",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 48 bits of data from vector input registers into 3-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_XYZW",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 64 bits of data from vector input registers into 4-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_USHORT",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface, zero extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SSHORT",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 16 bits of signed data from a buffer surface, sign extend to 32 bits and store the result into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORD",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 32 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX2",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 64 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX3",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 96 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_DWORDX4",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 128 bits of data from a buffer surface into a vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_BYTE",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 8 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_BYTE_D16_HI",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 8 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_SHORT",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 16 bits of data from a vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_SHORT_D16_HI",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 16 bits of data from the high 16 bits of a 32-bit vector register into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORD",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 32 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX2",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 64 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX3",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 96 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_DWORDX4",
    "architectures": [
      "cdna1"
    ],
    "description": "Store 128 bits of data from vector input registers into a buffer surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE_D16",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_UBYTE_D16_HI",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 8 bits of unsigned data from a buffer surface, zero extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE_D16",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SBYTE_D16_HI",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 8 bits of signed data from a buffer surface, sign extend to 16 bits and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SHORT_D16",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the low 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_SHORT_D16_HI",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 16 bits of unsigned data from a buffer surface and store the result into the high 16 bits of a 32-bit vector register.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_LOAD_FORMAT_D16_HI_X",
    "architectures": [
      "cdna1"
    ],
    "description": "Load 1-component formatted data from a buffer surface, convert the data to packed 16 bit integral or floating point format, then store the result into the high 16 bits of a 32-bit vector register. The resource descriptor specifies the data format of the surface.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_STORE_FORMAT_D16_HI_X",
    "architectures": [
      "cdna1"
    ],
    "description": "Convert 16 bits of data from the high 16 bits of a 32-bit vector input register into 1-component formatted data and store the data into a buffer surface. The instruction specifies the data format of the surface, overriding the resource descriptor.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP",
    "architectures": [
      "cdna1"
    ],
    "description": "Swap an unsigned 32-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP",
    "architectures": [
      "cdna1"
    ],
    "description": "Compare two unsigned 32-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD",
    "architectures": [
      "cdna1"
    ],
    "description": "Add two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB",
    "architectures": [
      "cdna1"
    ],
    "description": "Subtract an unsigned 32-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the minimum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the maximum of two signed 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 32-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND",
    "architectures": [
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR",
    "architectures": [
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR",
    "architectures": [
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 32-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC",
    "architectures": [
      "cdna1"
    ],
    "description": "Increment an unsigned 32-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC",
    "architectures": [
      "cdna1"
    ],
    "description": "Decrement an unsigned 32-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_F32",
    "architectures": [
      "cdna1"
    ],
    "description": "Add a single-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_PK_ADD_F16",
    "architectures": [
      "cdna1"
    ],
    "description": "Add a packed 2-component half-precision float value in the data register to a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SWAP_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Swap an unsigned 64-bit integer value in the data register with a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_CMPSWAP_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Compare two unsigned 64-bit integer values stored in the data comparison register and a location in a buffer surface. Modify the memory location with a value in the data source register iff the comparison is equal. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_ADD_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Add two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SUB_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Subtract an unsigned 64-bit integer value stored in the data register from a value stored in a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMIN_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the minimum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMIN_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the minimum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_SMAX_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the maximum of two signed 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_UMAX_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Select the maximum of two unsigned 64-bit integer inputs, given two values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_AND_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Calculate bitwise AND given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_OR_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Calculate bitwise OR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_XOR_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Calculate bitwise XOR given two unsigned 64-bit integer values stored in the data register and a location in a buffer surface. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_INC_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Increment an unsigned 64-bit integer value from a location in a buffer surface with wraparound to 0 if the value exceeds a value in the data register. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "BUFFER_ATOMIC_DEC_X2",
    "architectures": [
      "cdna1"
    ],
    "description": "Decrement an unsigned 64-bit integer value from a location in a buffer surface with wraparound to a value in the data register if the decrement yields a negative value. Store the original value from buffer surface into a vector register iff the GLC bit is set.",
    "args": [
      "VDATA",
      "VADDR",
      "SRSRC",
      "SOFFSET"
    ],
    "arg_types": [
      "register",
      "register",
      "register",
      "unknown"
    ],
    "available_encodings": [
      "ENC_MUBUF"
    ]
  },
  {
    "name": "V_MUL_LEGACY_F32",
    "architectures": [
      "cdna1"
    ],
    "description": "Multiply two floating point inputs and store the result in a vector register. Follows DX9 rules where 0.0 times anything produces 0.0 (this differs from other APIs when the other input is infinity or NaN).",
    "args": [
      "VDST",
      "SRC0",
      "VSRC1"
    ],
    "arg_types": [
      "register",
      "register",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP2",
      "ENC_VOP3",
      "VOP2_INST_LITERAL",
      "VOP2_VOP_DPP",
      "VOP2_VOP_SDWA"
    ]
  },
  {
    "name": "V_INTERP_P2_LEGACY_F16",
    "architectures": [
      "cdna1"
    ],
    "description": "Half-precision interpolation.",
    "args": [
      "VDST",
      "SRC1",
      "SRC0",
      "SRC2"
    ],
    "arg_types": [
      "register",
      "register",
      "special",
      "register"
    ],
    "available_encodings": [
      "ENC_VOP3"
    ]
  }
]
